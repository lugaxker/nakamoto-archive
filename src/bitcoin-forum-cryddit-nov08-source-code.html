<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
		<link rel="canonical" href="https://bitcointalk.org/index.php?topic=382374.0" />
		<title>Print Page - Bitcoin source from November 2008.</title>
		<style type="text/css">
			body
			{
				color: black;
				background-color: white;
			}
			body, td, .normaltext
			{
				font-family: Verdana, arial, helvetica, serif;
				font-size: small;
			}
			*, a:link, a:visited, a:hover, a:active
			{
				color: black !important;
			}
			table
			{
				empty-cells: show;
			}
			.code
			{
				font-size: x-small;
				font-family: monospace;
				border: 1px solid black;
				margin: 1px;
				padding: 1px;
			}
			.quote
			{
				font-size: x-small;
				border: 1px solid black;
				margin: 1px;
				padding: 1px;
			}
			.smalltext, .quoteheader, .codeheader
			{
				font-size: x-small;
			}
			.largetext
			{
				font-size: large;
			}
			hr
			{
				height: 1px;
				border: 0;
				color: black;
				background-color: black;
			}
		</style>
	</head>
	<body>
		<h1 class="largetext">Bitcoin Forum</h1>
		<h2 class="normaltext">Bitcoin => Development &amp; Technical Discussion => Topic started by: Cryddit on December 23, 2013, 07:27:01 PM</h2>

		<table width="90%" cellpadding="0" cellspacing="0" border="0">
			<tr>
				<td>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:27:01 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I have this archive in my email. &nbsp;<br /><br />This is the Bitcoin sources from November 16, 2008 - a few months before the current blockchain began. <br /><br />It is four source code files, and I&#039;m going to paste them into <del>four</del> five messages here. &nbsp;I hope that the forum software allows long posts; one of them is 66K. &nbsp;<br /><br />Edit:&nbsp; The forum software allows only 64K in a single post, so I split main.cpp into two posts.&nbsp; <br /><br />The post below this one is the contents of the file, main.h</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:30:00 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><pre><br /></pre><div class="codeheader">Code:</div><div class="code">// Copyright (c) 2008 Satoshi Nakamoto<br />//<br />// Permission is hereby granted, free of charge, to any person obtaining a copy<br />// of this software and associated documentation files (the &quot;Software&quot;), to deal<br />// in the Software without restriction, including without limitation the rights<br />// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br />// copies of the Software, and to permit persons to whom the Software is<br />// furnished to do so, subject to the following conditions:<br />//<br />// The above copyright notice and this permission notice shall be included in<br />// all copies or substantial portions of the Software.<br />//<br />// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br />// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br />// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT<br />// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR<br />// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br />// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br />// IN THE SOFTWARE.<br /><br />class COutPoint;<br />class CInPoint;<br />class CDiskTxPos;<br />class CCoinBase;<br />class CTxIn;<br />class CTxOut;<br />class CTransaction;<br />class CBlock;<br />class CBlockIndex;<br />class CWalletTx;<br />class CKeyItem;<br /><br />static const unsigned int MAX_SIZE = 0x02000000;<br />static const int64 COIN = 1000000;<br />static const int64 CENT = 10000;<br />static const int64 TRANSACTIONFEE = 1 * CENT; /// change this to a user options setting, optional fee can be zero<br />///static const unsigned int MINPROOFOFWORK = 40; /// need to decide the right difficulty to start with<br />static const unsigned int MINPROOFOFWORK = 20;&nbsp; /// ridiculously easy for testing<br /><br /><br /><br /><br /><br /><br /><br />extern map&lt;uint256, CBlockIndex*&gt; mapBlockIndex;<br />extern const uint256 hashGenesisBlock;<br />extern CBlockIndex* pindexGenesisBlock;<br />extern int nBestHeight;<br />extern CBlockIndex* pindexBest;<br />extern unsigned int nTransactionsUpdated;<br />extern int fGenerateBitcoins;<br /><br /><br /><br /><br /><br /><br /><br />FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=&quot;rb&quot;);<br />FILE* AppendBlockFile(unsigned int&amp; nFileRet);<br />bool AddKey(const CKey&amp; key);<br />vector&lt;unsigned char&gt; GenerateNewKey();<br />bool AddToWallet(const CWalletTx&amp; wtxIn);<br />void ReacceptWalletTransactions();<br />void RelayWalletTransactions();<br />bool LoadBlockIndex(bool fAllowNew=true);<br />bool BitcoinMiner();<br />bool ProcessMessages(CNode* pfrom);<br />bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream&amp; vRecv);<br />bool SendMessages(CNode* pto);<br />int64 CountMoney();<br />bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx&amp; txNew);<br />bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew);<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />class CDiskTxPos<br />{<br />public:<br />&nbsp; &nbsp; unsigned int nFile;<br />&nbsp; &nbsp; unsigned int nBlockPos;<br />&nbsp; &nbsp; unsigned int nTxPos;<br /><br />&nbsp; &nbsp; CDiskTxPos()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; SetNull();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nFile = nFileIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nBlockPos = nBlockPosIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nTxPos = nTxPosIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )<br />&nbsp; &nbsp; void SetNull() { nFile = -1; nBlockPos = 0; nTxPos = 0; }<br />&nbsp; &nbsp; bool IsNull() const { return (nFile == -1); }<br /><br />&nbsp; &nbsp; friend bool operator==(const CDiskTxPos&amp; a, const CDiskTxPos&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.nFile&nbsp; &nbsp; &nbsp;== b.nFile &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.nBlockPos == b.nBlockPos &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.nTxPos&nbsp; &nbsp; == b.nTxPos);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator!=(const CDiskTxPos&amp; a, const CDiskTxPos&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return !(a == b);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;null&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;(nFile=%d, nBlockPos=%d, nTxPos=%d)&quot;, nFile, nBlockPos, nTxPos);<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br />class CInPoint<br />{<br />public:<br />&nbsp; &nbsp; CTransaction* ptx;<br />&nbsp; &nbsp; unsigned int n;<br /><br />&nbsp; &nbsp; CInPoint() { SetNull(); }<br />&nbsp; &nbsp; CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }<br />&nbsp; &nbsp; void SetNull() { ptx = NULL; n = -1; }<br />&nbsp; &nbsp; bool IsNull() const { return (ptx == NULL &amp;&amp; n == -1); }<br />};<br /><br /><br /><br /><br />class COutPoint<br />{<br />public:<br />&nbsp; &nbsp; uint256 hash;<br />&nbsp; &nbsp; unsigned int n;<br /><br />&nbsp; &nbsp; COutPoint() { SetNull(); }<br />&nbsp; &nbsp; COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }<br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )<br />&nbsp; &nbsp; void SetNull() { hash = 0; n = -1; }<br />&nbsp; &nbsp; bool IsNull() const { return (hash == 0 &amp;&amp; n == -1); }<br /><br />&nbsp; &nbsp; friend bool operator&lt;(const COutPoint&amp; a, const COutPoint&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.hash &lt; b.hash || (a.hash == b.hash &amp;&amp; a.n &lt; b.n));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator==(const COutPoint&amp; a, const COutPoint&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.hash == b.hash &amp;&amp; a.n == b.n);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator!=(const COutPoint&amp; a, const COutPoint&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return !(a == b);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;COutPoint(%s, %d)&quot;, hash.ToString().substr(0,6).c_str(), n);<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br />//<br />// An input of a transaction.&nbsp; It contains the location of the previous<br />// transaction&#039;s output that it claims and a signature that matches the<br />// output&#039;s public key.<br />//<br />class CTxIn<br />{<br />public:<br />&nbsp; &nbsp; COutPoint prevout;<br />&nbsp; &nbsp; CScript scriptSig;<br /><br />&nbsp; &nbsp; CTxIn()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CTxIn(COutPoint prevoutIn, CScript scriptSigIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; prevout = prevoutIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; scriptSig = scriptSigIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; prevout = COutPoint(hashPrevTx, nOut);<br />&nbsp; &nbsp; &nbsp; &nbsp; scriptSig = scriptSigIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(prevout);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(scriptSig);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; bool IsPrevInMainChain() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return CTxDB(&quot;r&quot;).ContainsTx(prevout.hash);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator==(const CTxIn&amp; a, const CTxIn&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.prevout == b.prevout &amp;&amp; a.scriptSig == b.scriptSig);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator!=(const CTxIn&amp; a, const CTxIn&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return !(a == b);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CTxIn(&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; prevout.print();<br />&nbsp; &nbsp; &nbsp; &nbsp; if (prevout.IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;, coinbase %s)\n&quot;, HexStr(scriptSig.begin(), scriptSig.end(), false).c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (scriptSig.size() &gt;= 6)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;, scriptSig=%02x%02x&quot;, scriptSig[4], scriptSig[5]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;)\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsMine() const;<br />&nbsp; &nbsp; int64 GetDebit() const;<br />};<br /><br /><br /><br /><br />//<br />// An output of a transaction.&nbsp; It contains the public key that the next input<br />// must be able to sign with to claim it.<br />//<br />class CTxOut<br />{<br />public:<br />&nbsp; &nbsp; int64 nValue;<br />&nbsp; &nbsp; unsigned int nSequence;<br />&nbsp; &nbsp; CScript scriptPubKey;<br /><br />&nbsp; &nbsp; // disk only<br />&nbsp; &nbsp; CDiskTxPos posNext;&nbsp; //// so far this is only used as a flag, nothing uses the location<br /><br />public:<br />&nbsp; &nbsp; CTxOut()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nValue = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nSequence = UINT_MAX;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CTxOut(int64 nValueIn, CScript scriptPubKeyIn, int nSequenceIn=UINT_MAX)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nValue = nValueIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey = scriptPubKeyIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nSequence = nSequenceIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nValue);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nSequence);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(scriptPubKey);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nType &amp; SER_DISK)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(posNext);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; uint256 GetHash() const { return SerializeHash(*this); }<br /><br />&nbsp; &nbsp; bool IsFinal() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (nSequence == UINT_MAX);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsMine() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return ::IsMine(scriptPubKey);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; int64 GetCredit() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (IsMine())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nValue;<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator==(const CTxOut&amp; a, const CTxOut&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.nValue&nbsp; &nbsp; &nbsp; &nbsp;== b.nValue &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.nSequence&nbsp; &nbsp; == b.nSequence &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.scriptPubKey == b.scriptPubKey);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator!=(const CTxOut&amp; a, const CTxOut&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return !(a == b);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (scriptPubKey.size() &gt;= 6)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CTxOut(nValue=%I64d, nSequence=%u, scriptPubKey=%02x%02x, posNext=&quot;, nValue, nSequence, scriptPubKey[4], scriptPubKey[5]);<br />&nbsp; &nbsp; &nbsp; &nbsp; posNext.print();<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;)\n&quot;);<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br />//<br />// The basic transaction that is broadcasted on the network and contained in<br />// blocks.&nbsp; A transaction can contain multiple inputs and outputs.<br />//<br />class CTransaction<br />{<br />public:<br />&nbsp; &nbsp; vector&lt;CTxIn&gt; vin;<br />&nbsp; &nbsp; vector&lt;CTxOut&gt; vout;<br />&nbsp; &nbsp; unsigned int nLockTime;<br /><br /><br />&nbsp; &nbsp; CTransaction()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; SetNull();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(nType &amp; SER_GETHASH))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nVersion);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Set version on stream for writing back same version<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fRead &amp;&amp; s.nVersion == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.nVersion = nVersion;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vin);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vout);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nLockTime);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; void SetNull()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vin.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; vout.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; nLockTime = 0;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsNull() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (vin.empty() &amp;&amp; vout.empty());<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; uint256 GetHash() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return SerializeHash(*this);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool AllPrevInMainChain() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!txin.IsPrevInMainChain())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsFinal() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nLockTime == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nLockTime &lt; GetAdjustedTime())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!txout.IsFinal())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsUpdate(const CTransaction&amp; b) const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vin.size() != b.vin.size() || vout.size() != b.vout.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vin.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vin[i].prevout != b.vin[i].prevout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; bool fNewer = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nLowest = UINT_MAX;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vout.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vout[i].nSequence != b.vout[i].nSequence)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vout[i].nSequence &lt;= nLowest)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fNewer = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLowest = vout[i].nSequence;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b.vout[i].nSequence &lt; nLowest)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fNewer = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLowest = b.vout[i].nSequence;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return fNewer;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsCoinBase() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (vin.size() == 1 &amp;&amp; vin[0].prevout.IsNull());<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool CheckTransaction() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Basic checks that don&#039;t depend on any context<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vin.empty() || vout.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Check for negative values<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nValueOut = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.nValue &lt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueOut += txout.nValue;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (IsCoinBase())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vin[0].scriptSig.size() &gt; 100)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txin.prevout.IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsMine() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.IsMine())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; int64 GetDebit() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nDebit = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDebit += txin.GetDebit();<br />&nbsp; &nbsp; &nbsp; &nbsp; return nDebit;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; int64 GetCredit() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nCredit = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nCredit += txout.GetCredit();<br />&nbsp; &nbsp; &nbsp; &nbsp; return nCredit;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; int64 GetValueOut() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nValueOut = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.nValue &lt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;CTransaction::GetValueOut() : negative value&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueOut += txout.nValue;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return nValueOut;<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CAutoFile filein = OpenBlockFile(pos.nFile, 0, pfileRet ? &quot;rb+&quot; : &quot;rb&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!filein)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Read transaction<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; filein &gt;&gt; *this;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Return file pointer<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pfileRet)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pfileRet = filein.release();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; friend bool operator==(const CTransaction&amp; a, const CTransaction&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.vin&nbsp; &nbsp; &nbsp; &nbsp;== b.vin &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.vout&nbsp; &nbsp; &nbsp; == b.vout &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.nLockTime == b.nLockTime);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend bool operator!=(const CTransaction&amp; a, const CTransaction&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return !(a == b);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CTransaction(vin.size=%d, vout.size=%d, nLockTime=%d)\n&quot;,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vin.size(),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vout.size(),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLockTime);<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vin.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;&nbsp; &nbsp; &quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vin[i].print();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vout.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;&nbsp; &nbsp; &quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vout[i].print();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; bool TestDisconnectInputs(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return DisconnectInputs(txdb, mapTestPool, true);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool TestConnectInputs(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool, bool fMemoryTx, bool fIgnoreDiskConflicts, int64&amp; nFees)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return ConnectInputs(txdb, mapTestPool, CDiskTxPos(1, 1, 1), 0, true, fMemoryTx, fIgnoreDiskConflicts, nFees);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool DisconnectInputs(CTxDB&amp; txdb)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; static map&lt;uint256, CTransaction&gt; mapTestPool;<br />&nbsp; &nbsp; &nbsp; &nbsp; return DisconnectInputs(txdb, mapTestPool, false);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool ConnectInputs(CTxDB&amp; txdb, CDiskTxPos posThisTx, int nHeight)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; static map&lt;uint256, CTransaction&gt; mapTestPool;<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nFees;<br />&nbsp; &nbsp; &nbsp; &nbsp; return ConnectInputs(txdb, mapTestPool, posThisTx, nHeight, false, false, false, nFees);<br />&nbsp; &nbsp; }<br /><br />private:<br />&nbsp; &nbsp; bool DisconnectInputs(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool, bool fTest);<br />&nbsp; &nbsp; bool ConnectInputs(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool, CDiskTxPos posThisTx, int nHeight,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bool fTest, bool fMemoryTx, bool fIgnoreDiskConflicts, int64&amp; nFees);<br /><br />public:<br />&nbsp; &nbsp; bool AcceptTransaction(CTxDB&amp; txdb, bool fCheckInputs=true);<br />&nbsp; &nbsp; bool AcceptTransaction() { CTxDB txdb(&quot;r&quot;); return AcceptTransaction(txdb); }<br />&nbsp; &nbsp; bool ClientConnectInputs();<br />};<br /><br /><br /><br /><br /><br />//<br />// A transaction with a merkle branch linking it to the timechain<br />//<br />class CMerkleTx : public CTransaction<br />{<br />public:<br />&nbsp; &nbsp; uint256 hashBlock;<br />&nbsp; &nbsp; vector&lt;uint256&gt; vMerkleBranch;<br />&nbsp; &nbsp; int nIndex;<br /><br />&nbsp; &nbsp; CMerkleTx()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; Init();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CMerkleTx(const CTransaction&amp; txIn) : CTransaction(txIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; Init();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void Init()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; hashBlock = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nIndex = -1;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; nSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(nType &amp; SER_GETHASH))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nVersion);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(hashBlock);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vMerkleBranch);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nIndex);<br />&nbsp; &nbsp; )<br /><br /><br />&nbsp; &nbsp; int SetMerkleBranch();<br />&nbsp; &nbsp; int IsInMainChain() const;<br />&nbsp; &nbsp; bool AcceptTransaction(CTxDB&amp; txdb, bool fCheckInputs=true);<br />&nbsp; &nbsp; bool AcceptTransaction() { CTxDB txdb(&quot;r&quot;); return AcceptTransaction(txdb); }<br />};<br /><br /><br /><br /><br />//<br />// A transaction with a bunch of additional info that only the owner cares<br />// about.&nbsp; It includes any unrecorded transactions needed to link it back<br />// to the timechain.<br />//<br />class CWalletTx : public CMerkleTx<br />{<br />public:<br />&nbsp; &nbsp; vector&lt;CMerkleTx&gt; vtxPrev;<br />&nbsp; &nbsp; map&lt;string, string&gt; mapValue;<br />&nbsp; &nbsp; vector&lt;pair&lt;string, string&gt; &gt; vOrderForm;<br />&nbsp; &nbsp; unsigned int nTime;<br />&nbsp; &nbsp; char fFromMe;<br />&nbsp; &nbsp; char fSpent;<br /><br />&nbsp; &nbsp; //// probably need to sign the order info so know it came from payer<br /><br />&nbsp; &nbsp; CWalletTx()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; Init();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CWalletTx(const CMerkleTx&amp; txIn) : CMerkleTx(txIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; Init();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CWalletTx(const CTransaction&amp; txIn) : CMerkleTx(txIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; Init();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void Init()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nTime = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; fFromMe = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; fSpent = false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; /// would be nice for it to return the version number it reads, maybe use a reference<br />&nbsp; &nbsp; &nbsp; &nbsp; nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion, ser_action);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(nType &amp; SER_GETHASH))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nVersion);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vtxPrev);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(mapValue);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vOrderForm);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nTime);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(fFromMe);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(fSpent);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; bool WriteToDisk()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return CWalletDB().WriteTx(GetHash(), *this);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; void AddSupportingTransactions(CTxDB&amp; txdb);<br />&nbsp; &nbsp; void AddSupportingTransactions() { CTxDB txdb(&quot;r&quot;); AddSupportingTransactions(txdb); }<br /><br />&nbsp; &nbsp; bool AcceptWalletTransaction(CTxDB&amp; txdb, bool fCheckInputs=true);<br />&nbsp; &nbsp; bool AcceptWalletTransaction() { CTxDB txdb(&quot;r&quot;); return AcceptWalletTransaction(txdb); }<br /><br />&nbsp; &nbsp; void RelayWalletTransaction(CTxDB&amp; txdb);<br />&nbsp; &nbsp; void RelayWalletTransaction() { CTxDB txdb(&quot;r&quot;); RelayWalletTransaction(txdb); }<br />};<br /><br /><br /><br /><br /><br /><br />//<br />// Nodes collect new transactions into a block, hash them into a hash tree,<br />// and scan through nonce values to make the block&#039;s hash satisfy proof-of-work<br />// requirements.&nbsp; When they solve the proof-of-work, they broadcast the block<br />// to everyone and the block is added to the timechain.&nbsp; The first transaction<br />// in the block is a special one that creates a new coin owned by the creator<br />// of the block.<br />//<br />// Blocks are appended to blk0001.dat files on disk.&nbsp; Their location on disk<br />// is indexed by CBlockIndex objects in memory.<br />//<br />class CBlock<br />{<br />public:<br />&nbsp; &nbsp; // header<br />&nbsp; &nbsp; uint256 hashPrevBlock;<br />&nbsp; &nbsp; uint256 hashMerkleRoot;<br />&nbsp; &nbsp; unsigned int nTime;<br />&nbsp; &nbsp; unsigned int nBits;<br />&nbsp; &nbsp; unsigned int nNonce;<br /><br />&nbsp; &nbsp; // network and disk<br />&nbsp; &nbsp; vector&lt;CTransaction&gt; vtx;<br /><br />&nbsp; &nbsp; // memory only<br />&nbsp; &nbsp; mutable vector&lt;uint256&gt; vMerkleTree;<br /><br /><br />&nbsp; &nbsp; CBlock()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; SetNull();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(nType &amp; SER_GETHASH))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nVersion);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(hashPrevBlock);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(hashMerkleRoot);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nTime);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nBits);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nNonce);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // ConnectBlock depends on vtx being last so it can calculate offset<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(nType &amp; (SER_GETHASH|SER_BLOCKHEADERONLY)))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vtx);<br />&nbsp; &nbsp; &nbsp; &nbsp; else if (fRead)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const_cast&lt;CBlock*&gt;(this)-&gt;vtx.clear();<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; void SetNull()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; hashPrevBlock = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; hashMerkleRoot = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nTime = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nBits = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nNonce = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; vtx.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; vMerkleTree.clear();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsNull() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (nBits == 0);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; uint256 GetHash() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return Hash(BEGIN(hashPrevBlock), END(nNonce));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; uint256 BuildMerkleTree() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vMerkleTree.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vMerkleTree.push_back(tx.GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; int j = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nSize; i += 2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i2 = min(i+1, nSize-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),&nbsp; END(vMerkleTree[j+i]),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j += nSize;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return (vMerkleTree.empty() ? 0 : vMerkleTree.back());<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; vector&lt;uint256&gt; GetMerkleBranch(int nIndex) const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vMerkleTree.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BuildMerkleTree();<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;uint256&gt; vMerkleBranch;<br />&nbsp; &nbsp; &nbsp; &nbsp; int j = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int nSize = vtx.size(); nSize &gt; 1; nSize = (nSize + 1) / 2)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int i = min(nIndex^1, nSize-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vMerkleBranch.push_back(vMerkleTree[j+i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nIndex &gt;&gt;= 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j += nSize;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return vMerkleBranch;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; static uint256 CheckMerkleBranch(uint256 hash, const vector&lt;uint256&gt;&amp; vMerkleBranch, int nIndex)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const uint256&amp; otherside, vMerkleBranch)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nIndex &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nIndex &gt;&gt;= 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return hash;<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; bool WriteToDisk(bool fWriteTransactions, unsigned int&amp; nFileRet, unsigned int&amp; nBlockPosRet)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Open history file to append<br />&nbsp; &nbsp; &nbsp; &nbsp; CAutoFile fileout = AppendBlockFile(nFileRet);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fileout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fWriteTransactions)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileout.nType |= SER_BLOCKHEADERONLY;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Write index header<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nSize = fileout.GetSerializeSize(*this);<br />&nbsp; &nbsp; &nbsp; &nbsp; fileout &lt;&lt; FLATDATA(pchMessageStart) &lt;&lt; nSize;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Write block<br />&nbsp; &nbsp; &nbsp; &nbsp; nBlockPosRet = ftell(fileout);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nBlockPosRet == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; fileout &lt;&lt; *this;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; SetNull();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Open history file to read<br />&nbsp; &nbsp; &nbsp; &nbsp; CAutoFile filein = OpenBlockFile(nFile, nBlockPos, &quot;rb&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!filein)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fReadTransactions)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filein.nType |= SER_BLOCKHEADERONLY;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Read block<br />&nbsp; &nbsp; &nbsp; &nbsp; filein &gt;&gt; *this;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Check the header<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nBits &lt; MINPROOFOFWORK || GetHash() &gt; (~uint256(0) &gt;&gt; nBits))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CBlock::ReadFromDisk : errors in block header&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CBlock(hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%u, nNonce=%u, vtx=%d)\n&quot;,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashPrevBlock.ToString().substr(0,6).c_str(),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashMerkleRoot.ToString().substr(0,6).c_str(),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTime, nBits, nNonce,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vtx.size());<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vtx.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;&nbsp; &quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vtx[i].print();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;&nbsp; vMerkleTree: &quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vMerkleTree.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s &quot;, vMerkleTree[i].ToString().substr(0,6).c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n&quot;);<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; bool ReadFromDisk(const CBlockIndex* blockindex, bool fReadTransactions);<br />&nbsp; &nbsp; bool TestDisconnectBlock(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool);<br />&nbsp; &nbsp; bool TestConnectBlock(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool);<br />&nbsp; &nbsp; bool DisconnectBlock();<br />&nbsp; &nbsp; bool ConnectBlock(unsigned int nFile, unsigned int nBlockPos, int nHeight);<br />&nbsp; &nbsp; bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, bool fWriteDisk);<br />&nbsp; &nbsp; bool CheckBlock() const;<br />&nbsp; &nbsp; bool AcceptBlock();<br />};<br /><br /><br /><br /><br /><br /><br />//<br />// The timechain is a tree shaped structure starting with the<br />// genesis block at the root, with each block potentially having multiple<br />// candidates to be the next block.&nbsp; pprev and pnext link a path through the<br />// main/longest chain.&nbsp; A blockindex may have multiple pprev pointing back<br />// to it, but pnext will only point forward to the longest branch, or will<br />// be null if the block is not part of the longest chain.<br />//<br />class CBlockIndex<br />{<br />public:<br />&nbsp; &nbsp; CBlockIndex* pprev;<br />&nbsp; &nbsp; CBlockIndex* pnext;<br />&nbsp; &nbsp; unsigned int nFile;<br />&nbsp; &nbsp; unsigned int nBlockPos;<br />&nbsp; &nbsp; int nHeight;<br /><br /><br />&nbsp; &nbsp; CBlockIndex()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; pprev = NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; pnext = NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; nFile = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nBlockPos = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nHeight = 0;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CBlockIndex(unsigned int nFileIn, unsigned int nBlockPosIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; pprev = NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; pnext = NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; nFile = nFileIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nBlockPos = nBlockPosIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nHeight = 0;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsInMainChain() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (pnext || this == pindexBest);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool EraseBlockFromDisk()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Open history file<br />&nbsp; &nbsp; &nbsp; &nbsp; CAutoFile fileout = OpenBlockFile(nFile, nBlockPos, &quot;rb+&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fileout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Overwrite with empty null block<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; block.SetNull();<br />&nbsp; &nbsp; &nbsp; &nbsp; fileout &lt;&lt; block;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; bool TestDisconnectBlock(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!block.ReadFromDisk(nFile, nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return block.TestDisconnectBlock(txdb, mapTestPool);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool TestConnectBlock(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!block.ReadFromDisk(nFile, nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return block.TestConnectBlock(txdb, mapTestPool);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool DisconnectBlock()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!block.ReadFromDisk(nFile, nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return block.DisconnectBlock();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool ConnectBlock()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!block.ReadFromDisk(nFile, nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return block.ConnectBlock(nFile, nBlockPos, nHeight);<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%d, nHeight=%d)\n&quot;,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pprev, pnext, nFile, nBlockPos, nHeight);<br />&nbsp; &nbsp; }<br />};<br /><br />void PrintTimechain();<br /><br /><br /><br /><br /><br /><br /><br />//<br />// Describes a place in the timechain to another node such that if the<br />// other node doesn&#039;t have the same branch, it can find a recent common trunk.<br />// The further back it is, the further before the branch point it may be.<br />//<br />class CBlockLocator<br />{<br />protected:<br />&nbsp; &nbsp; vector&lt;uint256&gt; vHave;<br />public:<br /><br />&nbsp; &nbsp; CBlockLocator()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; explicit CBlockLocator(const CBlockIndex* pindex)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; Set(pindex);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; explicit CBlockLocator(uint256 hashBlock)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hashBlock);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (mi != mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set((*mi).second);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(nType &amp; SER_GETHASH))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nVersion);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(vHave);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; void Set(const CBlockIndex* pindex)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vHave.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; int nStep = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; while (pindex)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.ReadFromDisk(pindex, false);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vHave.push_back(block.GetHash());<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Exponentially larger steps back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; pindex &amp;&amp; i &lt; nStep; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindex = pindex-&gt;pprev;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vHave.size() &gt; 10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nStep *= 2;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CBlockIndex* GetBlockIndex()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Find the first block the caller has in the main chain<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const uint256&amp; hash, vHave)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hash);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi != mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindex = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pindex-&gt;IsInMainChain())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return pindex;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return pindexGenesisBlock;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; uint256 GetBlockHash()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Find the first block the caller has in the main chain<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const uint256&amp; hash, vHave)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hash);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi != mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindex = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pindex-&gt;IsInMainChain())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return hash;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return hashGenesisBlock;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; int GetHeight()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindex = GetBlockIndex();<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!pindex)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; return pindex-&gt;nHeight;<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />extern map&lt;uint256, CTransaction&gt; mapTransactions;<br />extern map&lt;uint256, CWalletTx&gt; mapWallet;<br />extern vector&lt;pair&lt;uint256, bool&gt; &gt; vWalletUpdated;<br />extern CCriticalSection cs_mapWallet;<br />extern map&lt;vector&lt;unsigned char&gt;, CPrivKey&gt; mapKeys;<br />extern map&lt;uint160, vector&lt;unsigned char&gt; &gt; mapPubKeys;<br />extern CCriticalSection cs_mapKeys;<br />extern CKey keyUser;<br /></div>[/pre]</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:32:23 PM</b>
					<hr />
					<div style="margin: 0 5ex;">This is the first half of main.cpp.&nbsp; I&#039;m going to post it in two halves, because the forum software allows a bit less than 66K in one post.&nbsp; <br /><br /><pre></pre><div class="codeheader">Code:</div><div class="code">// Copyright (c) 2008 Satoshi Nakamoto<br />//<br />// Permission is hereby granted, free of charge, to any person obtaining a copy<br />// of this software and associated documentation files (the &quot;Software&quot;), to deal<br />// in the Software without restriction, including without limitation the rights<br />// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br />// copies of the Software, and to permit persons to whom the Software is<br />// furnished to do so, subject to the following conditions:<br />//<br />// The above copyright notice and this permission notice shall be included in<br />// all copies or substantial portions of the Software.<br />//<br />// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br />// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br />// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT<br />// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR<br />// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br />// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br />// IN THE SOFTWARE.<br /><br />#include &quot;headers.h&quot;<br />#include &quot;sha.h&quot;<br /><br /><br /><br /><br /><br />//<br />// Global state<br />//<br /><br />map&lt;uint256, CTransaction&gt; mapTransactions;<br />CCriticalSection cs_mapTransactions;<br />unsigned int nTransactionsUpdated = 0;<br />/// mapNextTx is only used anymore to track disk tx outpoints used by memory txes<br />map&lt;COutPoint, CInPoint&gt; mapNextTx;<br /><br />map&lt;uint256, CBlockIndex*&gt; mapBlockIndex;<br />const uint256 hashGenesisBlock(&quot;0x000006b15d1327d67e971d1de9116bd60a3a01556c91b6ebaa416ebc0cfaa646&quot;);<br />CBlockIndex* pindexGenesisBlock = NULL;<br />int nBestHeight = -1;<br />uint256 hashTimeChainBest = 0;<br />CBlockIndex* pindexBest = NULL;<br /><br />map&lt;uint256, CBlock*&gt; mapOrphanBlocks;<br />multimap&lt;uint256, CBlock*&gt; mapOrphanBlocksByPrev;<br /><br />map&lt;uint256, CWalletTx&gt; mapWallet;<br />vector&lt;pair&lt;uint256, bool&gt; &gt; vWalletUpdated;<br />CCriticalSection cs_mapWallet;<br /><br />map&lt;vector&lt;unsigned char&gt;, CPrivKey&gt; mapKeys;<br />map&lt;uint160, vector&lt;unsigned char&gt; &gt; mapPubKeys;<br />CCriticalSection cs_mapKeys;<br />CKey keyUser;<br /><br />int fGenerateBitcoins;<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// mapKeys<br />//<br /><br />bool AddKey(const CKey&amp; key)<br />{<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapKeys)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; mapKeys[key.GetPubKey()] = key.GetPrivKey();<br />&nbsp; &nbsp; &nbsp; &nbsp; mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());<br />}<br /><br />vector&lt;unsigned char&gt; GenerateNewKey()<br />{<br />&nbsp; &nbsp; CKey key;<br />&nbsp; &nbsp; key.MakeNewKey();<br />&nbsp; &nbsp; if (!AddKey(key))<br />&nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;GenerateNewKey() : AddKey failed\n&quot;);<br />&nbsp; &nbsp; return key.GetPubKey();<br />}<br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// mapWallet<br />//<br /><br />bool AddToWallet(const CWalletTx&amp; wtxIn)<br />{<br />&nbsp; &nbsp; uint256 hash = wtxIn.GetHash();<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Inserts only if not already there, returns tx inserted or tx found<br />&nbsp; &nbsp; &nbsp; &nbsp; pair&lt;map&lt;uint256, CWalletTx&gt;::iterator, bool&gt; ret = mapWallet.insert(make_pair(hash, wtxIn));<br />&nbsp; &nbsp; &nbsp; &nbsp; CWalletTx&amp; wtx = (*ret.first).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; bool fInsertedNew = ret.second;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;AddToWallet %s&nbsp; %d\n&quot;, wtxIn.GetHash().ToString().c_str(), fInsertedNew);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fInsertedNew)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Merge<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fUpdated = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (wtxIn.hashBlock != 0 &amp;&amp; wtxIn.hashBlock != wtx.hashBlock)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.hashBlock = wtxIn.hashBlock;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fUpdated = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (wtxIn.fFromMe &amp;&amp; wtxIn.fFromMe != wtx.fFromMe)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.fFromMe = wtxIn.fFromMe;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fUpdated = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (wtxIn.fSpent &amp;&amp; wtxIn.fSpent != wtx.fSpent)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.fSpent = wtxIn.fSpent;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fUpdated = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!fUpdated)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Write to disk<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!wtx.WriteToDisk())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Notify UI<br />&nbsp; &nbsp; &nbsp; &nbsp; vWalletUpdated.push_back(make_pair(hash, fInsertedNew));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Refresh UI<br />&nbsp; &nbsp; MainFrameRepaint();<br />&nbsp; &nbsp; return true;<br />}<br /><br />bool AddToWalletIfMine(const CTransaction&amp; tx, const CBlock* pblock)<br />{<br />&nbsp; &nbsp; if (tx.IsMine())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CWalletTx wtx(tx);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pblock)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.hashBlock = pblock-&gt;GetHash();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.nTime = pblock-&gt;nTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.nTime = GetAdjustedTime();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return AddToWallet(wtx);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return true;<br />}<br /><br />void ReacceptWalletTransactions()<br />{<br />&nbsp; &nbsp; // Reaccept any txes of ours that aren&#039;t already in a block<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(PAIRTYPE(const uint256, CWalletTx)&amp; item, mapWallet)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CWalletTx&amp; wtx = item.second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!txdb.ContainsTx(wtx.GetHash()))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.AcceptWalletTransaction(txdb, false);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />}<br /><br />void RelayWalletTransactions()<br />{<br />&nbsp; &nbsp; static int64 nLastTime;<br />&nbsp; &nbsp; if (GetTime() - nLastTime &lt; 15 * 60)<br />&nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; nLastTime = GetTime();<br /><br />&nbsp; &nbsp; // Rebroadcast any of our txes that aren&#039;t in a block yet<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(PAIRTYPE(const uint256, CWalletTx)&amp; item, mapWallet)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item.second.RelayWalletTransaction(txdb);<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// CTransaction<br />//<br /><br />bool CTxIn::IsMine() const<br />{<br />&nbsp; &nbsp; map&lt;uint256, CWalletTx&gt;::iterator mi = mapWallet.find(prevout.hash);<br />&nbsp; &nbsp; if (mi != mapWallet.end())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; const CWalletTx&amp; prev = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (prevout.n &lt; prev.vout.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev.vout[prevout.n].IsMine())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return false;<br />}<br /><br />int64 CTxIn::GetDebit() const<br />{<br />&nbsp; &nbsp; map&lt;uint256, CWalletTx&gt;::iterator mi = mapWallet.find(prevout.hash);<br />&nbsp; &nbsp; if (mi != mapWallet.end())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; const CWalletTx&amp; prev = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (prevout.n &lt; prev.vout.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prev.vout[prevout.n].IsMine())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return prev.vout[prevout.n].nValue;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return 0;<br />}<br /><br /><br /><br /><br />int CMerkleTx::SetMerkleBranch()<br />{<br />&nbsp; &nbsp; if (fClient)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (hashBlock == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Load the block this tx is in<br />&nbsp; &nbsp; &nbsp; &nbsp; CDiskTxPos pos;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!CTxDB(&quot;r&quot;).ReadTxPos(GetHash(), pos))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Update the tx&#039;s hashBlock<br />&nbsp; &nbsp; &nbsp; &nbsp; hashBlock = block.GetHash();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Locate the transaction<br />&nbsp; &nbsp; &nbsp; &nbsp; for (nIndex = 0; nIndex &lt; block.vtx.size(); nIndex++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (block.vtx[nIndex] == *(CTransaction*)this)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nIndex == block.vtx.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vMerkleBranch.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nIndex = -1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: SetMerkleBranch() : couldn&#039;t find tx in block\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Fill in merkle branch<br />&nbsp; &nbsp; &nbsp; &nbsp; vMerkleBranch = block.GetMerkleBranch(nIndex);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Is the tx in a block that&#039;s in the main chain<br />&nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hashBlock);<br />&nbsp; &nbsp; if (mi == mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; CBlockIndex* pindex = (*mi).second;<br />&nbsp; &nbsp; if (!pindex || !pindex-&gt;IsInMainChain())<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br /><br />&nbsp; &nbsp; return pindexBest-&gt;nHeight - pindex-&gt;nHeight + 1;<br />}<br /><br />void CWalletTx::AddSupportingTransactions(CTxDB&amp; txdb)<br />{<br />&nbsp; &nbsp; vtxPrev.clear();<br /><br />&nbsp; &nbsp; const int COPY_DEPTH = 3;<br />&nbsp; &nbsp; if (SetMerkleBranch() &lt; COPY_DEPTH)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;uint256&gt; vWorkQueue;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vWorkQueue.push_back(txin.prevout.hash);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, const CMerkleTx*&gt; mapWalletPrev;<br />&nbsp; &nbsp; &nbsp; &nbsp; set&lt;uint256&gt; setAlreadyDone;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vWorkQueue.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 hash = vWorkQueue[i];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (setAlreadyDone.count(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setAlreadyDone.insert(hash);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CMerkleTx tx;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mapWallet.count(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tx = mapWallet[hash];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CMerkleTx&amp; txWalletPrev, mapWallet[hash].vtxPrev)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapWalletPrev[txWalletPrev.GetHash()] = &amp;txWalletPrev;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (mapWalletPrev.count(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tx = *mapWalletPrev[hash];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (!fClient &amp;&amp; txdb.ReadDiskTx(hash, tx))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR: AddSupportingTransactions() : unsupported transaction\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nDepth = tx.SetMerkleBranch();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vtxPrev.push_back(tx);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nDepth &lt; COPY_DEPTH)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, tx.vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vWorkQueue.push_back(txin.prevout.hash);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; reverse(vtxPrev.begin(), vtxPrev.end());<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />bool CTransaction::DisconnectInputs(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool, bool fTest)<br />{<br />&nbsp; &nbsp; // Relinquish previous transactions&#039; posNext pointers<br />&nbsp; &nbsp; if (!IsCoinBase())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COutPoint prevout = txin.prevout;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAutoFile fileout = NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction txPrevBuf;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txPrev = (fTest ? mapTestPool[prevout.hash] : txPrevBuf);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txPrev.IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get prev tx from disk<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Version -1 tells unserialize to set version so we write back same version<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileout.SetVersion(-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!txdb.ReadDiskTx(prevout.hash, txPrev, &amp;fileout))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prevout.n &gt;= txPrev.vout.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Relinquish posNext pointer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txPrev.vout[prevout.n].posNext.SetNull();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!fTest)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileout &lt;&lt; txPrev;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (fTest)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Put a blocked-off copy of this transaction in the test pool<br />&nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txPool = mapTestPool[GetHash()];<br />&nbsp; &nbsp; &nbsp; &nbsp; txPool = *this;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CTxOut&amp; txout, txPool.vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txout.posNext = CDiskTxPos(1, 1, 1);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Remove transaction from index<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!txdb.EraseTxPos(*this))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Resurect single transaction objects<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!IsCoinBase())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AcceptTransaction(txdb, false);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br />bool CTransaction::ConnectInputs(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool, CDiskTxPos posThisTx, int nHeight,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bool fTest, bool fMemoryTx, bool fIgnoreDiskConflicts, int64&amp; nFees)<br />{<br />&nbsp; &nbsp; // Take over previous transactions&#039; posNext pointers<br />&nbsp; &nbsp; if (!IsCoinBase())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nValueIn = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vin.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COutPoint prevout = vin[i].prevout;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAutoFile fileout = NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction txPrevBuf;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txPrev = (fTest ? mapTestPool[prevout.hash] : txPrevBuf);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txPrev.IsNull() &amp;&amp; fTest &amp;&amp; fMemoryTx &amp;&amp; mapTransactions.count(prevout.hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get prev tx from single transactions in memory<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txPrev = mapTransactions[prevout.hash];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (txPrev.IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get prev tx from disk<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Version -1 tells unserialize to set version so we write back same version<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileout.SetVersion(-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!txdb.ReadDiskTx(prevout.hash, txPrev, &amp;fileout))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;ConnectInputs() : prev tx not found&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // If tx will only be connected in a reorg,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // then these outpoints will be checked at that time<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fIgnoreDiskConflicts)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CTxOut&amp; txout, txPrev.vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txout.posNext.SetNull();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prevout.n &gt;= txPrev.vout.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Verify signature<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!VerifySignature(txPrev, *this, i))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;ConnectInputs() : VerifySignature failed&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Check for conflicts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!txPrev.vout[prevout.n].posNext.IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;ConnectInputs() : prev tx already used&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Flag outpoints as used<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txPrev.vout[prevout.n].posNext = posThisTx;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Write back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!fTest)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileout &lt;&lt; txPrev;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueIn += txPrev.vout[prevout.n].nValue;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Tally transaction fees<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nTransactionFee = nValueIn - GetValueOut();<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nTransactionFee &lt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; nFees += nTransactionFee;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (fTest)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Add transaction to test pool<br />&nbsp; &nbsp; &nbsp; &nbsp; mapTestPool[GetHash()] = *this;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Add transaction to disk index<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!txdb.WriteTxPos(*this, posThisTx, nHeight))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Delete redundant single transaction objects<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapTransactions)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapNextTx.erase(txin.prevout);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapTransactions.erase(GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br />bool CTransaction::AcceptTransaction(CTxDB&amp; txdb, bool fCheckInputs)<br />{<br />&nbsp; &nbsp; // Coinbase is only valid in a block, not as a loose transaction<br />&nbsp; &nbsp; if (IsCoinBase())<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;AcceptTransaction() : coinbase as individual tx&quot;);<br /><br />&nbsp; &nbsp; if (!CheckTransaction())<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;AcceptTransaction() : CheckTransaction failed&quot;);<br /><br />&nbsp; &nbsp; uint256 hash = GetHash();<br />&nbsp; &nbsp; if (mapTransactions.count(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Check for conflicts with in-memory transactions<br />&nbsp; &nbsp; // and allow replacing with a newer version of the same transaction<br />&nbsp; &nbsp; CTransaction* ptxOld = NULL;<br />&nbsp; &nbsp; for (int i = 0; i &lt; vin.size(); i++)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; COutPoint outpoint = vin[i].prevout;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (mapNextTx.count(outpoint))<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ptxOld == NULL)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptxOld = mapNextTx[outpoint].ptx;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!IsUpdate(*ptxOld))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (ptxOld != mapNextTx[outpoint].ptx)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Check against previous transactions<br />&nbsp; &nbsp; map&lt;uint256, CTransaction&gt; mapTestPool;<br />&nbsp; &nbsp; int64 nFees = 0;<br />&nbsp; &nbsp; if (fCheckInputs)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!TestConnectInputs(txdb, mapTestPool, true, false, nFees))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;AcceptTransaction() : TestConnectInputs failed&quot;);<br /><br />&nbsp; &nbsp; // Store transaction in memory<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapTransactions)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (ptxOld)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;mapTransaction.erase(%s) replacing with new version\n&quot;, ptxOld-&gt;GetHash().ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapTransactions.erase(ptxOld-&gt;GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; //printf(&quot;mapTransaction.insert(%s)\n&nbsp; &quot;, hash.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; //print();<br />&nbsp; &nbsp; &nbsp; &nbsp; mapTransactions[hash] = *this;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vin.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapNextTx[vin[i].prevout] = CInPoint(&amp;mapTransactions[hash], i);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // If updated, erase old tx from wallet<br />&nbsp; &nbsp; if (ptxOld)<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapWallet.erase(ptxOld-&gt;GetHash());<br /><br />&nbsp; &nbsp; nTransactionsUpdated++;<br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br /><br />int CMerkleTx::IsInMainChain() const<br />{<br />&nbsp; &nbsp; if (hashBlock == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br /><br />&nbsp; &nbsp; // Find the block it claims to be in<br />&nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hashBlock);<br />&nbsp; &nbsp; if (mi == mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; CBlockIndex* pindex = (*mi).second;<br />&nbsp; &nbsp; if (!pindex || !pindex-&gt;IsInMainChain())<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br /><br />&nbsp; &nbsp; // Get merkle root<br />&nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; if (!block.ReadFromDisk(pindex, false))<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br /><br />&nbsp; &nbsp; // Make sure the merkle branch connects to this block<br />&nbsp; &nbsp; if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != block.hashMerkleRoot)<br />&nbsp; &nbsp; &nbsp; &nbsp; return 0;<br /><br />&nbsp; &nbsp; return pindexBest-&gt;nHeight - pindex-&gt;nHeight + 1;<br />}<br /><br /><br /><br />bool CMerkleTx::AcceptTransaction(CTxDB&amp; txdb, bool fCheckInputs)<br />{<br />&nbsp; &nbsp; if (fClient)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!IsInMainChain() &amp;&amp; !ClientConnectInputs())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; return CTransaction::AcceptTransaction(txdb, false);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return CTransaction::AcceptTransaction(txdb, fCheckInputs);<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br />bool CWalletTx::AcceptWalletTransaction(CTxDB&amp; txdb, bool fCheckInputs)<br />{<br />&nbsp; &nbsp; foreach(CMerkleTx&amp; tx, vtxPrev)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hash = tx.GetHash();<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!mapTransactions.count(hash) &amp;&amp; !txdb.ContainsTx(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tx.AcceptTransaction(txdb, fCheckInputs);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return AcceptTransaction(txdb, fCheckInputs);<br />}<br /><br /><br />void CWalletTx::RelayWalletTransaction(CTxDB&amp; txdb)<br />{<br />&nbsp; &nbsp; foreach(CMerkleTx&amp; tx, vtxPrev)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hash = tx.GetHash();<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!txdb.ContainsTx(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; uint256 hash = GetHash();<br />&nbsp; &nbsp; if (!txdb.ContainsTx(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// CBlock and CBlockIndex<br />//<br /><br />bool CBlock::ReadFromDisk(const CBlockIndex* pblockindex, bool fReadTransactions)<br />{<br />&nbsp; &nbsp; return ReadFromDisk(pblockindex-&gt;nFile, pblockindex-&gt;nBlockPos, fReadTransactions);<br />}<br /><br />int64 GetBlockValue(int64 nFees)<br />{<br />&nbsp; &nbsp; int64 nSubsidy = 10000 * CENT;<br />&nbsp; &nbsp; for (int i = 100000; i &lt;= nBestHeight; i += 100000)<br />&nbsp; &nbsp; &nbsp; &nbsp; nSubsidy /= 2;<br />&nbsp; &nbsp; return nSubsidy + nFees;<br />}<br /><br />unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast)<br />{<br />&nbsp; &nbsp; const unsigned int nTargetTimespan = 30 * 24 * 60 * 60;<br />&nbsp; &nbsp; const unsigned int nTargetSpacing = 15 * 60;<br />&nbsp; &nbsp; const unsigned int nIntervals = nTargetTimespan / nTargetSpacing;<br /><br />&nbsp; &nbsp; // Cache<br />&nbsp; &nbsp; static const CBlockIndex* pindexLastCache;<br />&nbsp; &nbsp; static unsigned int nBitsCache;<br />&nbsp; &nbsp; static CCriticalSection cs_cache;<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_cache)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pindexLast &amp;&amp; pindexLast == pindexLastCache)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nBitsCache;<br /><br />&nbsp; &nbsp; // Go back 30 days<br />&nbsp; &nbsp; const CBlockIndex* pindexFirst = pindexLast;<br />&nbsp; &nbsp; for (int i = 0; pindexFirst &amp;&amp; i &lt; nIntervals; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; pindexFirst = pindexFirst-&gt;pprev;<br />&nbsp; &nbsp; if (pindexFirst == NULL)<br />&nbsp; &nbsp; &nbsp; &nbsp; return MINPROOFOFWORK;<br /><br />&nbsp; &nbsp; // Load first and last block<br />&nbsp; &nbsp; CBlock blockFirst;<br />&nbsp; &nbsp; if (!blockFirst.ReadFromDisk(pindexFirst, false))<br />&nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;GetNextWorkRequired() : blockFirst.ReadFromDisk failed\n&quot;);<br />&nbsp; &nbsp; CBlock blockLast;<br />&nbsp; &nbsp; if (!blockLast.ReadFromDisk(pindexLast, false))<br />&nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;GetNextWorkRequired() : blockLast.ReadFromDisk failed\n&quot;);<br /><br />&nbsp; &nbsp; // Limit one change per timespan<br />&nbsp; &nbsp; unsigned int nBits = blockLast.nBits;<br />&nbsp; &nbsp; if (blockFirst.nBits == blockLast.nBits)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTimespan = blockLast.nTime - blockFirst.nTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nTimespan &gt; nTargetTimespan * 2 &amp;&amp; nBits &gt;= MINPROOFOFWORK)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBits--;<br />&nbsp; &nbsp; &nbsp; &nbsp; else if (nTimespan &lt; nTargetTimespan / 2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBits++;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_cache)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; pindexLastCache = pindexLast;<br />&nbsp; &nbsp; &nbsp; &nbsp; nBitsCache = nBits;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return nBits;<br />}<br /><br />uint256 GetOrphanRoot(const CBlock* pblock)<br />{<br />&nbsp; &nbsp; // Work back to the first block in the orphan chain<br />&nbsp; &nbsp; while (mapOrphanBlocks.count(pblock-&gt;hashPrevBlock))<br />&nbsp; &nbsp; &nbsp; &nbsp; pblock = mapOrphanBlocks[pblock-&gt;hashPrevBlock];<br />&nbsp; &nbsp; return pblock-&gt;hashPrevBlock;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />bool CBlock::TestDisconnectBlock(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool)<br />{<br />&nbsp; &nbsp; foreach(CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!tx.TestDisconnectInputs(txdb, mapTestPool))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; return true;<br />}<br /><br />bool CBlock::TestConnectBlock(CTxDB&amp; txdb, map&lt;uint256, CTransaction&gt;&amp; mapTestPool)<br />{<br />&nbsp; &nbsp; int64 nFees = 0;<br />&nbsp; &nbsp; foreach(CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!tx.TestConnectInputs(txdb, mapTestPool, false, false, nFees))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; if (vtx[0].GetValueOut() != GetBlockValue(nFees))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; return true;<br />}<br /><br />bool CBlock::DisconnectBlock()<br />{<br />&nbsp; &nbsp; CTxDB txdb;<br />&nbsp; &nbsp; foreach(CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!tx.DisconnectInputs(txdb))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; return true;<br />}<br /><br />bool CBlock::ConnectBlock(unsigned int nFile, unsigned int nBlockPos, int nHeight)<br />{<br />&nbsp; &nbsp; //// issue here: it doesn&#039;t know the version<br />&nbsp; &nbsp; unsigned int nTxPos = nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());<br /><br />&nbsp; &nbsp; CTxDB txdb;<br />&nbsp; &nbsp; foreach(CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CDiskTxPos posThisTx(nFile, nBlockPos, nTxPos);<br />&nbsp; &nbsp; &nbsp; &nbsp; nTxPos += ::GetSerializeSize(tx, SER_DISK);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (!tx.ConnectInputs(txdb, posThisTx, nHeight))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; txdb.Close();<br /><br />&nbsp; &nbsp; // Watch for transactions paying to me<br />&nbsp; &nbsp; foreach(CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; AddToWalletIfMine(tx, this);<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br />bool Reorganize(CBlockIndex* pindexNew, bool fWriteDisk)<br />{<br />&nbsp; &nbsp; // Find the fork<br />&nbsp; &nbsp; CBlockIndex* pfork = pindexBest;<br />&nbsp; &nbsp; CBlockIndex* plonger = pindexNew;<br />&nbsp; &nbsp; while (pfork != plonger)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!(pfork = pfork-&gt;pprev))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; while (plonger-&gt;nHeight &gt; pfork-&gt;nHeight)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(plonger = plonger-&gt;pprev))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // List of what to disconnect<br />&nbsp; &nbsp; vector&lt;CBlockIndex*&gt; vDisconnect;<br />&nbsp; &nbsp; for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex-&gt;pprev)<br />&nbsp; &nbsp; &nbsp; &nbsp; vDisconnect.push_back(pindex);<br /><br />&nbsp; &nbsp; // List of what to connect<br />&nbsp; &nbsp; vector&lt;CBlockIndex*&gt; vConnect;<br />&nbsp; &nbsp; for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex-&gt;pprev)<br />&nbsp; &nbsp; &nbsp; &nbsp; vConnect.push_back(pindex);<br />&nbsp; &nbsp; reverse(vConnect.begin(), vConnect.end());<br /><br />&nbsp; &nbsp; // Pretest the reorg<br />&nbsp; &nbsp; if (fWriteDisk)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CTransaction&gt; mapTestPool;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CBlockIndex* pindex, vDisconnect)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pindex-&gt;TestDisconnectBlock(txdb, mapTestPool))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; bool fValid = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CBlockIndex* pindex, vConnect)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fValid = fValid &amp;&amp; pindex-&gt;TestConnectBlock(txdb, mapTestPool);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!fValid)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Invalid block, delete the rest of this branch<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.ReadFromDisk(pindex, false);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindex-&gt;EraseBlockFromDisk();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapBlockIndex.erase(block.GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete pindex;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fValid)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Disconnect shorter branch<br />&nbsp; &nbsp; foreach(CBlockIndex* pindex, vDisconnect)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fWriteDisk &amp;&amp; !pindex-&gt;DisconnectBlock())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pindex-&gt;pprev)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindex-&gt;pprev-&gt;pnext = NULL;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Connect longer branch<br />&nbsp; &nbsp; foreach(CBlockIndex* pindex, vConnect)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fWriteDisk &amp;&amp; !pindex-&gt;ConnectBlock())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pindex-&gt;pprev)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindex-&gt;pprev-&gt;pnext = pindex;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br />bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, bool fWriteDisk)<br />{<br />&nbsp; &nbsp; uint256 hash = GetHash();<br /><br />&nbsp; &nbsp; // Add to block index<br />&nbsp; &nbsp; CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos);<br />&nbsp; &nbsp; if (!pindexNew)<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; mapBlockIndex[hash] = pindexNew;<br />&nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hashPrevBlock);<br />&nbsp; &nbsp; if (mi != mapBlockIndex.end())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; pindexNew-&gt;pprev = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; pindexNew-&gt;nHeight = pindexNew-&gt;pprev-&gt;nHeight + 1;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // New best<br />&nbsp; &nbsp; if (pindexNew-&gt;nHeight &gt; nBestHeight)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pindexGenesisBlock == NULL &amp;&amp; hash == hashGenesisBlock)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindexGenesisBlock = pindexNew;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else if (hashPrevBlock == hashTimeChainBest)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Adding to current best branch<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fWriteDisk)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pindexNew-&gt;ConnectBlock())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindexNew-&gt;pprev-&gt;pnext = pindexNew;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // New best branch<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!Reorganize(pindexNew, fWriteDisk))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // New best link<br />&nbsp; &nbsp; &nbsp; &nbsp; nBestHeight = pindexNew-&gt;nHeight;<br />&nbsp; &nbsp; &nbsp; &nbsp; hashTimeChainBest = hash;<br />&nbsp; &nbsp; &nbsp; &nbsp; pindexBest = pindexNew;<br />&nbsp; &nbsp; &nbsp; &nbsp; nTransactionsUpdated++;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Relay wallet transactions that haven&#039;t gotten in yet<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fWriteDisk &amp;&amp; nTime &gt; GetAdjustedTime() - 30 * 60)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelayWalletTransactions();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; MainFrameRepaint();<br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br /><br />template&lt;typename Stream&gt;<br />bool ScanMessageStart(Stream&amp; s)<br />{<br />&nbsp; &nbsp; // Scan ahead to the next pchMessageStart, which should normally be immediately<br />&nbsp; &nbsp; // at the file pointer.&nbsp; Leaves file pointer at end of pchMessageStart.<br />&nbsp; &nbsp; s.clear(0);<br />&nbsp; &nbsp; short prevmask = s.exceptions(0);<br />&nbsp; &nbsp; const char* p = BEGIN(pchMessageStart);<br />&nbsp; &nbsp; try<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; loop<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char c;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.read(&amp;c, 1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (s.fail())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.clear(0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.exceptions(prevmask);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (*p != c)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = BEGIN(pchMessageStart);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (*p == c)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (++p == END(pchMessageStart))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.clear(0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.exceptions(prevmask);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; catch (...)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; s.clear(0);<br />&nbsp; &nbsp; &nbsp; &nbsp; s.exceptions(prevmask);<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />}<br /><br />FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)<br />{<br />&nbsp; &nbsp; if (nFile == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; FILE* file = fopen(strprintf(&quot;blk%04d.dat&quot;, nFile).c_str(), pszMode);<br />&nbsp; &nbsp; if (!file)<br />&nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; if (nBlockPos != 0 &amp;&amp; !strchr(pszMode, &#039;a&#039;) &amp;&amp; !strchr(pszMode, &#039;w&#039;))<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fseek(file, nBlockPos, SEEK_SET) != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(file);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return file;<br />}<br /><br />static unsigned int nCurrentBlockFile = 1;<br /><br />FILE* AppendBlockFile(unsigned int&amp; nFileRet)<br />{<br />&nbsp; &nbsp; nFileRet = 0;<br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; FILE* file = OpenBlockFile(nCurrentBlockFile, 0, &quot;ab&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!file)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (fseek(file, 0, SEEK_END) != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; &nbsp; &nbsp; // FAT32 filesize max 4GB, fseek and ftell max 2GB, so we must stay under 2GB<br />&nbsp; &nbsp; &nbsp; &nbsp; if (ftell(file) &lt; 0x7F000000 - MAX_SIZE)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFileRet = nCurrentBlockFile;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return file;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; fclose(file);<br />&nbsp; &nbsp; &nbsp; &nbsp; nCurrentBlockFile++;<br />&nbsp; &nbsp; }<br />}<br /><br />bool LoadBlockIndex(bool fAllowNew)<br />{<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; // Load from disk<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; for (nCurrentBlockFile = 1;; nCurrentBlockFile++)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CAutoFile filein = OpenBlockFile(nCurrentBlockFile, 0, &quot;rb&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (filein == NULL)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nCurrentBlockFile &gt; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nCurrentBlockFile--;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!fAllowNew)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //// debug<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Genesis Block:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // GetHash()&nbsp; &nbsp; &nbsp; = 0x000006b15d1327d67e971d1de9116bd60a3a01556c91b6ebaa416ebc0cfaa646<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // hashPrevBlock&nbsp; = 0x0000000000000000000000000000000000000000000000000000000000000000<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // hashMerkleRoot = 0x769a5e93fac273fd825da42d39ead975b5d712b2d50953f35a4fdebdec8083e3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // txNew.vin[0].scriptSig&nbsp; &nbsp; &nbsp; = 247422313<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // txNew.vout[0].nValue&nbsp; &nbsp; &nbsp; &nbsp; = 10000<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // txNew.vout[0].scriptPubKey&nbsp; = OP_CODESEPARATOR 0x31D18A083F381B4BDE37B649AACF8CD0AFD88C53A3587ECDB7FAF23D449C800AF1CE516199390BFE42991F10E7F5340F2A63449F0B639A7115C667E5D7B051D404 OP_CHECKSIG<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // nTime&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 1221069728<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // nBits&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 20<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // nNonce&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 141755<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // CBlock(hashPrevBlock=000000, hashMerkleRoot=769a5e, nTime=1221069728, nBits=20, nNonce=141755, vtx=1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp;CTransaction(vin.size=1, vout.size=1, nLockTime=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; &nbsp;CTxIn(COutPoint(000000, -1), coinbase 04695dbf0e)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; &nbsp;CTxOut(nValue=10000, nSequence=4294967295, scriptPubKey=51b0, posNext=null)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp;vMerkleTree: 769a5e<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Genesis block<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction txNew;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txNew.vin.resize(1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txNew.vout.resize(1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txNew.vin[0].scriptSig&nbsp; &nbsp; &nbsp;= CScript() &lt;&lt; 247422313;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txNew.vout[0].nValue&nbsp; &nbsp; &nbsp; &nbsp;= 10000;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txNew.vout[0].scriptPubKey = CScript() &lt;&lt; OP_CODESEPARATOR &lt;&lt; CBigNum(&quot;0x31D18A083F381B4BDE37B649AACF8CD0AFD88C53A3587ECDB7FAF23D449C800AF1CE516199390BFE42991F10E7F5340F2A63449F0B639A7115C667E5D7B051D404&quot;) &lt;&lt; OP_CHECKSIG;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.vtx.push_back(txNew);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.hashPrevBlock = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.hashMerkleRoot = block.BuildMerkleTree();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.nTime&nbsp; = 1221069728;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.nBits&nbsp; = 20;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.nNonce = 141755;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, block.GetHash().ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, block.hashMerkleRoot.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, hashGenesisBlock.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txNew.vout[0].scriptPubKey.print();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.print();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(block.hashMerkleRoot == uint256(&quot;0x769a5e93fac273fd825da42d39ead975b5d712b2d50953f35a4fdebdec8083e3&quot;));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(block.GetHash() == hashGenesisBlock);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Start new block file<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nFile;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBlockPos;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!block.WriteToDisk(true, nFile, nBlockPos))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!block.AddToBlockIndex(nFile, nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; int nFilesize = GetFilesize(filein);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nFilesize == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; filein.nType |= SER_BLOCKHEADERONLY;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; while (ScanMessageStart(filein))<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Read index header<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nSize;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filein &gt;&gt; nSize;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nSize &gt; MAX_SIZE || ftell(filein) + nSize &gt; nFilesize)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Read block header<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nBlockPos = ftell(filein);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filein &gt;&gt; block;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Skip transactions<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fseek(filein, nBlockPos + nSize, SEEK_SET) != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; //// is this all we want to do if there&#039;s a file error like this?<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Add to block index without updating disk<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!block.AddToBlockIndex(nCurrentBlockFile, nBlockPos, false))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br />void PrintTimechain()<br />{<br />&nbsp; &nbsp; // precompute tree structure<br />&nbsp; &nbsp; map&lt;CBlockIndex*, vector&lt;CBlockIndex*&gt; &gt; mapNext;<br />&nbsp; &nbsp; for (map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindex = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; mapNext[pindex-&gt;pprev].push_back(pindex);<br />&nbsp; &nbsp; &nbsp; &nbsp; // test<br />&nbsp; &nbsp; &nbsp; &nbsp; //while (rand() % 3 == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; mapNext[pindex-&gt;pprev].push_back(pindex);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; vector&lt;pair&lt;int, CBlockIndex*&gt; &gt; vStack;<br />&nbsp; &nbsp; vStack.push_back(make_pair(0, pindexGenesisBlock));<br /><br />&nbsp; &nbsp; int nPrevCol = 0;<br />&nbsp; &nbsp; while (!vStack.empty())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int nCol = vStack.back().first;<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindex = vStack.back().second;<br />&nbsp; &nbsp; &nbsp; &nbsp; vStack.pop_back();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // print split or gap<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nCol &gt; nPrevCol)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nCol-1; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;| &quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;|\\\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else if (nCol &lt; nPrevCol)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nCol; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;| &quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;|\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; nPrevCol = nCol;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // print columns<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; nCol; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;| &quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // print item<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d (%u,%u)\n&quot;, pindex-&gt;nHeight, pindex-&gt;nFile, pindex-&gt;nBlockPos);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // put the main timechain first<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CBlockIndex*&gt;&amp; vNext = mapNext[pindex];<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vNext.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vNext[i]-&gt;pnext)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(vNext[0], vNext[i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // iterate children<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vNext.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vStack.push_back(make_pair(nCol+i, vNext[i]));<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br /><br /><br /><br />bool CBlock::CheckBlock() const<br />{<br />&nbsp; &nbsp; // Size limits<br />&nbsp; &nbsp; if (vtx.empty() || vtx.size() &gt; MAX_SIZE || ::GetSerializeSize(*this, SER_DISK) &gt; MAX_SIZE)<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : size limits failed&quot;);<br /><br />&nbsp; &nbsp; // Check timestamp<br />&nbsp; &nbsp; if (nTime &gt; GetAdjustedTime() + 36 * 60 * 60)<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : block timestamp out of range&quot;);<br /><br />&nbsp; &nbsp; // Check proof of work matches claimed amount<br />&nbsp; &nbsp; if (nBits &lt; MINPROOFOFWORK)<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : nBits below minimum&quot;);<br />&nbsp; &nbsp; if (GetHash() &gt; (~uint256(0) &gt;&gt; nBits))<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : hash doesn&#039;t match nBits&quot;);<br /><br />&nbsp; &nbsp; // First transaction must be coinbase, the rest must not be<br />&nbsp; &nbsp; if (vtx.empty() || !vtx[0].IsCoinBase())<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : first tx is not coinbase&quot;);<br />&nbsp; &nbsp; for (int i = 1; i &lt; vtx.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vtx[i].IsCoinBase())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : more than one coinbase&quot;);<br /><br />&nbsp; &nbsp; // Check transactions<br />&nbsp; &nbsp; foreach(const CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!tx.CheckTransaction())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : CheckTransaction failed&quot;);<br /><br />&nbsp; &nbsp; // Check merkleroot<br />&nbsp; &nbsp; if (hashMerkleRoot != BuildMerkleTree())<br />&nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;CheckBlock() : hashMerkleRoot mismatch&quot;);<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br />bool CBlock::AcceptBlock()<br />{<br />&nbsp; &nbsp; // Check for duplicate<br />&nbsp; &nbsp; uint256 hash = GetHash();<br />&nbsp; &nbsp; if (mapBlockIndex.count(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Get prev block index<br />&nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(hashPrevBlock);<br />&nbsp; &nbsp; if (mi == mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; CBlockIndex* pindexPrev = (*mi).second;<br /><br />&nbsp; &nbsp; // Check timestamp against prev<br />&nbsp; &nbsp; CBlock blockPrev;<br />&nbsp; &nbsp; if (!blockPrev.ReadFromDisk(pindexPrev, false))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; if (nTime &lt;= blockPrev.nTime)<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Check proof of work<br />&nbsp; &nbsp; if (nBits != GetNextWorkRequired(pindexPrev))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Check transaction inputs and verify signatures<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CTransaction&gt; mapTestPool;<br />&nbsp; &nbsp; &nbsp; &nbsp; bool fIgnoreDiskConflicts = (hashPrevBlock != hashTimeChainBest);<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nFees = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!tx.TestConnectInputs(txdb, mapTestPool, false, fIgnoreDiskConflicts, nFees))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;AcceptBlock() : TestConnectInputs failed&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vtx[0].GetValueOut() != GetBlockValue(nFees))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Write block to history file<br />&nbsp; &nbsp; unsigned int nFile;<br />&nbsp; &nbsp; unsigned int nBlockPos;<br />&nbsp; &nbsp; if (!WriteToDisk(!fClient, nFile, nBlockPos))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; if (!AddToBlockIndex(nFile, nBlockPos, true))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; if (hashTimeChainBest == hash)<br />&nbsp; &nbsp; &nbsp; &nbsp; RelayInventory(CInv(MSG_BLOCK, hash));<br /><br />&nbsp; &nbsp; // Add atoms to user reviews for coins created<br />&nbsp; &nbsp; vector&lt;unsigned char&gt; vchPubKey;<br />&nbsp; &nbsp; if (ExtractPubKey(vtx[0].vout[0].scriptPubKey, false, vchPubKey))<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint64 nRand = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; RAND_bytes((unsigned char*)&amp;nRand, sizeof(nRand));<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned short nAtom = nRand % (USHRT_MAX - 100) + 100;<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned short&gt; vAtoms(1, nAtom);<br />&nbsp; &nbsp; &nbsp; &nbsp; AddAtomsAndPropagate(Hash(vchPubKey.begin(), vchPubKey.end()), vAtoms, true);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br />bool ProcessBlock(CNode* pfrom, CBlock* pblock)<br />{<br />&nbsp; &nbsp; // Check for duplicate<br />&nbsp; &nbsp; uint256 hash = pblock-&gt;GetHash();<br />&nbsp; &nbsp; if (mapBlockIndex.count(hash) || mapOrphanBlocks.count(hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Preliminary checks<br />&nbsp; &nbsp; if (!pblock-&gt;CheckBlock())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CheckBlock FAILED\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; delete pblock;<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // If don&#039;t already have its previous block, shunt it off to holding area until we get it<br />&nbsp; &nbsp; if (!mapBlockIndex.count(pblock-&gt;hashPrevBlock))<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; mapOrphanBlocks.insert(make_pair(hash, pblock));<br />&nbsp; &nbsp; &nbsp; &nbsp; mapOrphanBlocksByPrev.insert(make_pair(pblock-&gt;hashPrevBlock, pblock));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Ask this guy to fill in what we&#039;re missing<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pfrom)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;getblocks&quot;, CBlockLocator(pindexBest), GetOrphanRoot(pblock));<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Store to disk<br />&nbsp; &nbsp; if (!pblock-&gt;AcceptBlock())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;AcceptBlock FAILED\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; delete pblock;<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; delete pblock;<br /><br />&nbsp; &nbsp; // Now process any orphan blocks that depended on this one<br />&nbsp; &nbsp; for (multimap&lt;uint256, CBlock*&gt;::iterator mi = mapOrphanBlocksByPrev.lower_bound(hash);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mi != mapOrphanBlocksByPrev.upper_bound(hash);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++mi)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlock* pblockOrphan = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; pblockOrphan-&gt;AcceptBlock();<br />&nbsp; &nbsp; &nbsp; &nbsp; mapOrphanBlocks.erase(pblockOrphan-&gt;GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; delete pblockOrphan;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; mapOrphanBlocksByPrev.erase(hash);<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /></div>[/pre]</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:33:53 PM</b>
					<hr />
					<div style="margin: 0 5ex;">This is the second half of main.cpp.&nbsp; <br /><br /><pre></pre><div class="codeheader">Code:</div><div class="code"><br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// Messages<br />//<br /><br /><br />bool AlreadyHave(const CInv&amp; inv)<br />{<br />&nbsp; &nbsp; switch (inv.type)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; case MSG_TX:&nbsp; &nbsp; &nbsp; &nbsp; return mapTransactions.count(inv.hash);<br />&nbsp; &nbsp; case MSG_BLOCK:&nbsp; &nbsp; &nbsp;return mapBlockIndex.count(inv.hash) || mapOrphanBlocks.count(inv.hash);<br />&nbsp; &nbsp; case MSG_REVIEW:&nbsp; &nbsp; return true;<br />&nbsp; &nbsp; case MSG_PRODUCT:&nbsp; &nbsp;return mapProducts.count(inv.hash);<br />&nbsp; &nbsp; case MSG_TABLE:&nbsp; &nbsp; &nbsp;return mapTables.count(inv.hash);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; // Don&#039;t know what it is, just say we already got one<br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br /><br /><br /><br />bool ProcessMessages(CNode* pfrom)<br />{<br />&nbsp; &nbsp; CDataStream&amp; vRecv = pfrom-&gt;vRecv;<br />&nbsp; &nbsp; if (vRecv.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; printf(&quot;ProcessMessages(%d bytes)\n&quot;, vRecv.size());<br /><br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; // Message format<br />&nbsp; &nbsp; //&nbsp; (4) message start<br />&nbsp; &nbsp; //&nbsp; (12) command<br />&nbsp; &nbsp; //&nbsp; (4) size<br />&nbsp; &nbsp; //&nbsp; (x) data<br />&nbsp; &nbsp; //<br /><br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Scan for message start<br />&nbsp; &nbsp; &nbsp; &nbsp; CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vRecv.end() - pstart &lt; sizeof(CMessageHeader))<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vRecv.size() &gt; sizeof(CMessageHeader))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n\nPROCESSMESSAGE MESSAGESTART NOT FOUND\n\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vRecv.erase(vRecv.begin(), vRecv.end() - sizeof(CMessageHeader));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pstart - vRecv.begin() &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n\nPROCESSMESSAGE SKIPPED %d BYTES\n\n&quot;, pstart - vRecv.begin());<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv.erase(vRecv.begin(), pstart);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Read header<br />&nbsp; &nbsp; &nbsp; &nbsp; CMessageHeader hdr;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; hdr;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!hdr.IsValid())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n\nPROCESSMESSAGE: ERRORS IN HEADER %s\n\n\n&quot;, hdr.GetCommand().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; string strCommand = hdr.GetCommand();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Message size<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nMessageSize = hdr.nMessageSize;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nMessageSize &gt; vRecv.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Rewind and wait for rest of message<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ///// need a mechanism to give up waiting for overlong message size error<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;MESSAGE-BREAK 2\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vRecv.insert(vRecv.begin(), BEGIN(hdr), END(hdr));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Copy message to its own buffer<br />&nbsp; &nbsp; &nbsp; &nbsp; CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv.ignore(nMessageSize);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Process message<br />&nbsp; &nbsp; &nbsp; &nbsp; bool fRet = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fRet = ProcessMessage(pfrom, strCommand, vMsg);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; CATCH_PRINT_EXCEPTION(&quot;ProcessMessage()&quot;)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fRet)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ProcessMessage(%s, %d bytes) from %s to %s FAILED\n&quot;, strCommand.c_str(), nMessageSize, pfrom-&gt;addr.ToString().c_str(), addrLocalHost.ToString().c_str());<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; vRecv.Compact();<br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br />bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream&amp; vRecv)<br />{<br />&nbsp; &nbsp; static map&lt;unsigned int, vector&lt;unsigned char&gt; &gt; mapReuseKey;<br />&nbsp; &nbsp; CheckForShutdown(2);<br />&nbsp; &nbsp; printf(&quot;received: %-12s (%d bytes)&nbsp; &quot;, strCommand.c_str(), vRecv.size());<br />&nbsp; &nbsp; for (int i = 0; i &lt; min(vRecv.size(), (unsigned int)25); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%02x &quot;, vRecv[i] &amp; 0xff);<br />&nbsp; &nbsp; printf(&quot;\n&quot;);<br /><br /><br />&nbsp; &nbsp; if (strCommand == &quot;version&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Can only do this once<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pfrom-&gt;nVersion != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; pfrom-&gt;nVersion &gt;&gt; pfrom-&gt;nServices &gt;&gt; nTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pfrom-&gt;nVersion == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;vSend.SetVersion(min(pfrom-&gt;nVersion, VERSION));<br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;vRecv.SetVersion(min(pfrom-&gt;nVersion, VERSION));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;fClient = !(pfrom-&gt;nServices &amp; NODE_NETWORK);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pfrom-&gt;fClient)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;vSend.nType |= SER_BLOCKHEADERONLY;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;vRecv.nType |= SER_BLOCKHEADERONLY;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; AddTimeData(pfrom-&gt;addr.ip, nTime);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Ask the first connected node for block updates<br />&nbsp; &nbsp; &nbsp; &nbsp; static bool fAskedForBlocks;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!fAskedForBlocks &amp;&amp; !pfrom-&gt;fClient)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fAskedForBlocks = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;getblocks&quot;, CBlockLocator(pindexBest), uint256(0));<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (pfrom-&gt;nVersion == 0)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Must have a version message before anything else<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;addr&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CAddress&gt; vAddr;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; vAddr;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Store the new addresses<br />&nbsp; &nbsp; &nbsp; &nbsp; CAddrDB addrdb;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CAddress&amp; addr, vAddr)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (AddAddress(addrdb, addr))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Put on lists to send to other nodes<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;setAddrKnown.insert(addr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pnode-&gt;setAddrKnown.count(addr))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;vAddrToSend.push_back(addr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;inv&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CInv&gt; vInv;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; vInv;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CInv&amp; inv, vInv)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;&nbsp; got inventory: %s&nbsp; %s\n&quot;, inv.ToString().c_str(), AlreadyHave(inv) ? &quot;have&quot; : &quot;new&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(pfrom-&gt;cs_inventory)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;setInventoryKnown.insert(inv);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!AlreadyHave(inv))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;AskFor(inv);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (inv.type == MSG_BLOCK &amp;&amp; mapOrphanBlocks.count(inv.hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;getblocks&quot;, CBlockLocator(pindexBest), GetOrphanRoot(mapOrphanBlocks[inv.hash]));<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;getdata&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CInv&gt; vInv;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; vInv;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CInv&amp; inv, vInv)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;received getdata for: %s\n&quot;, inv.ToString().c_str());<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (inv.type == MSG_BLOCK)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Send block from disk<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CBlockIndex*&gt;::iterator mi = mapBlockIndex.find(inv.hash);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi != mapBlockIndex.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.ReadFromDisk((*mi).second, !pfrom-&gt;fClient);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;block&quot;, block);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (inv.IsKnownType())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Send stream from relay memory<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapRelay)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;CInv, CDataStream&gt;::iterator mi = mapRelay.find(inv);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi != mapRelay.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(inv.GetCommand(), (*mi).second);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;getblocks&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlockLocator locator;<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashStop;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; locator &gt;&gt; hashStop;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Find the first block the caller has in the main chain<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlockIndex* pindex = locator.GetBlockIndex();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Send the rest of the chain<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pindex)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pindex = pindex-&gt;pnext;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (; pindex; pindex = pindex-&gt;pnext)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CBlock block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block.ReadFromDisk(pindex, !pfrom-&gt;fClient);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (block.GetHash() == hashStop)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;block&quot;, block);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;getmywtxes&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CBlockLocator locator;<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;uint160&gt; vPubKeyHashes;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; locator &gt;&gt; vPubKeyHashes;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Find the owner&#039;s new transactions<br />&nbsp; &nbsp; &nbsp; &nbsp; int nHeight = locator.GetHeight();<br />&nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(uint160 hash160, vPubKeyHashes)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CTransaction&gt; vtx;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txdb.ReadOwnerTxes(hash160, nHeight, vtx))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTransaction&amp; tx, vtx)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Upgrade transaction to a fully supported CWalletTx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CWalletTx wtx(tx);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wtx.AddSupportingTransactions(txdb);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;wtx&quot;, wtx);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;wtx&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CWalletTx wtx;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; wtx;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (!wtx.AcceptWalletTransaction())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;message wtx : AcceptWalletTransaction failed!&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; AddToWallet(wtx);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;tx&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CDataStream vMsg(vRecv);<br />&nbsp; &nbsp; &nbsp; &nbsp; CTransaction tx;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; tx;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; CInv inv(MSG_TX, tx.GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;AddInventoryKnown(inv);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (tx.AcceptTransaction())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AddToWalletIfMine(tx, NULL);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelayMessage(inv, vMsg);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapAlreadyAskedFor.erase(inv);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;block&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; auto_ptr&lt;CBlock&gt; pblock(new CBlock);<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; *pblock;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;received block:\n&quot;); pblock-&gt;print();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; CInv inv(MSG_BLOCK, pblock-&gt;GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;AddInventoryKnown(inv);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; if (ProcessBlock(pfrom, pblock.release()))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapAlreadyAskedFor.erase(inv);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;getaddr&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;vAddrToSend.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; //// need to expand the time range if not enough found<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nSince = GetAdjustedTime() - 60 * 60; // in the last hour<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapAddresses)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const PAIRTYPE(vector&lt;unsigned char&gt;, CAddress)&amp; item, mapAddresses)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const CAddress&amp; addr = item.second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (addr.nTime &gt; nSince)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;vAddrToSend.push_back(addr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;checkorder&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashReply;<br />&nbsp; &nbsp; &nbsp; &nbsp; CWalletTx order;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; hashReply &gt;&gt; order;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; /// we have a chance to check the order here<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Keep giving the same key to the same ip until they use it<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!mapReuseKey.count(pfrom-&gt;addr.ip))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapReuseKey[pfrom-&gt;addr.ip] = GenerateNewKey();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Send back approval of order and pubkey to use<br />&nbsp; &nbsp; &nbsp; &nbsp; CScript scriptPubKey;<br />&nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey &lt;&lt; OP_CODESEPARATOR &lt;&lt; mapReuseKey[pfrom-&gt;addr.ip] &lt;&lt; OP_CHECKSIG;<br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;reply&quot;, hashReply, (int)0, scriptPubKey);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;submitorder&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashReply;<br />&nbsp; &nbsp; &nbsp; &nbsp; CWalletTx wtxNew;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; hashReply &gt;&gt; wtxNew;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Broadcast<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!wtxNew.AcceptWalletTransaction())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;reply&quot;, hashReply, (int)1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error(&quot;submitorder AcceptWalletTransaction() failed, returning error 1&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; AddToWallet(wtxNew);<br />&nbsp; &nbsp; &nbsp; &nbsp; wtxNew.RelayWalletTransaction();<br />&nbsp; &nbsp; &nbsp; &nbsp; mapReuseKey.erase(pfrom-&gt;addr.ip);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Send back confirmation<br />&nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;PushMessage(&quot;reply&quot;, hashReply, (int)0);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else if (strCommand == &quot;reply&quot;)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashReply;<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv &gt;&gt; hashReply;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; CRequestTracker tracker;<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(pfrom-&gt;cs_mapRequests)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;uint256, CRequestTracker&gt;::iterator mi = pfrom-&gt;mapRequests.find(hashReply);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mi != pfrom-&gt;mapRequests.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tracker = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pfrom-&gt;mapRequests.erase(mi);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!tracker.IsNull())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tracker.fn(tracker.param1, vRecv);<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Ignore unknown commands for extensibility<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ProcessMessage(%s) : Ignored unknown message\n&quot;, strCommand.c_str());<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; if (!vRecv.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ProcessMessage(%s) : %d extra bytes\n&quot;, strCommand.c_str(), vRecv.size());<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />bool SendMessages(CNode* pto)<br />{<br />&nbsp; &nbsp; CheckForShutdown(2);<br /><br />&nbsp; &nbsp; // Don&#039;t send anything until we get their version message<br />&nbsp; &nbsp; if (pto-&gt;nVersion == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br /><br /><br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; // Message: addr<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; vector&lt;CAddress&gt; vAddrToSend;<br />&nbsp; &nbsp; vAddrToSend.reserve(pto-&gt;vAddrToSend.size());<br />&nbsp; &nbsp; foreach(const CAddress&amp; addr, pto-&gt;vAddrToSend)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!pto-&gt;setAddrKnown.count(addr))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAddrToSend.push_back(addr);<br />&nbsp; &nbsp; pto-&gt;vAddrToSend.clear();<br />&nbsp; &nbsp; if (!vAddrToSend.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; pto-&gt;PushMessage(&quot;addr&quot;, vAddrToSend);<br /><br /><br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; // Message: inventory<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; vector&lt;CInv&gt; vInventoryToSend;<br />&nbsp; &nbsp; CRITICAL_BLOCK(pto-&gt;cs_inventory)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vInventoryToSend.reserve(pto-&gt;vInventoryToSend.size());<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CInv&amp; inv, pto-&gt;vInventoryToSend)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pto-&gt;setInventoryKnown.count(inv))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vInventoryToSend.push_back(inv);<br />&nbsp; &nbsp; &nbsp; &nbsp; pto-&gt;vInventoryToSend.clear();<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; if (!vInventoryToSend.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; pto-&gt;PushMessage(&quot;inv&quot;, vInventoryToSend);<br /><br /><br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; // Message: getdata<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; vector&lt;CInv&gt; vAskFor;<br />&nbsp; &nbsp; int64 nNow = GetTime();<br />&nbsp; &nbsp; while (!pto-&gt;mapAskFor.empty() &amp;&amp; (*pto-&gt;mapAskFor.begin()).first &lt;= nNow)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; const CInv&amp; inv = (*pto-&gt;mapAskFor.begin()).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;getdata %s\n&quot;, inv.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!AlreadyHave(inv))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAskFor.push_back(inv);<br />&nbsp; &nbsp; &nbsp; &nbsp; pto-&gt;mapAskFor.erase(pto-&gt;mapAskFor.begin());<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; if (!vAskFor.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; pto-&gt;PushMessage(&quot;getdata&quot;, vAskFor);<br /><br /><br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// BitcoinMiner<br />//<br /><br />int FormatHashBlocks(void* pbuffer, unsigned int len)<br />{<br />&nbsp; &nbsp; unsigned char* pdata = (unsigned char*)pbuffer;<br />&nbsp; &nbsp; unsigned int blocks = 1 + ((len + 8) / 64);<br />&nbsp; &nbsp; unsigned char* pend = pdata + 64 * blocks;<br />&nbsp; &nbsp; memset(pdata + len, 0, 64 * blocks - len);<br />&nbsp; &nbsp; pdata[len] = 0x80;<br />&nbsp; &nbsp; unsigned int bits = len * 8;<br />&nbsp; &nbsp; pend[-1] = (bits &gt;&gt; 0) &amp; 0xff;<br />&nbsp; &nbsp; pend[-2] = (bits &gt;&gt; 8) &amp; 0xff;<br />&nbsp; &nbsp; pend[-3] = (bits &gt;&gt; 16) &amp; 0xff;<br />&nbsp; &nbsp; pend[-4] = (bits &gt;&gt; 24) &amp; 0xff;<br />&nbsp; &nbsp; return blocks;<br />}<br /><br />using CryptoPP::ByteReverse;<br />static int detectlittleendian = 1;<br /><br />void BlockSHA256(const void* pin, unsigned int nBlocks, void* pout)<br />{<br />&nbsp; &nbsp; unsigned int* pinput = (unsigned int*)pin;<br />&nbsp; &nbsp; unsigned int* pstate = (unsigned int*)pout;<br /><br />&nbsp; &nbsp; CryptoPP::SHA256::InitState(pstate);<br /><br />&nbsp; &nbsp; if (*(char*)&amp;detectlittleendian != 0)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int n = 0; n &lt; nBlocks; n++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int pbuf[16];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; 16; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pbuf[i] = ByteReverse(pinput[n * 16 + i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CryptoPP::SHA256::Transform(pstate, pbuf);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; 8; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate[i] = ByteReverse(pstate[i]);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int n = 0; n &lt; nBlocks; n++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CryptoPP::SHA256::Transform(pstate, pinput + n * 16);<br />&nbsp; &nbsp; }<br />}<br /><br /><br />bool BitcoinMiner()<br />{<br />&nbsp; &nbsp; printf(&quot;BitcoinMiner started\n&quot;);<br /><br />&nbsp; &nbsp; SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);<br /><br /><br /><br />&nbsp; &nbsp; CBlock blockPrev;<br />&nbsp; &nbsp; while (fGenerateBitcoins)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(3);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Create coinbase tx<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; CTransaction txNew;<br />&nbsp; &nbsp; &nbsp; &nbsp; txNew.vin.resize(1);<br />&nbsp; &nbsp; &nbsp; &nbsp; txNew.vin[0].prevout.SetNull();<br />&nbsp; &nbsp; &nbsp; &nbsp; CBigNum bnNonce; // this nonce is so multiple processes working for the same keyUser<br />&nbsp; &nbsp; &nbsp; &nbsp; BN_rand_range(&amp;bnNonce, &amp;CBigNum(INT_MAX));&nbsp; // don&#039;t cover the same ground<br />&nbsp; &nbsp; &nbsp; &nbsp; txNew.vin[0].scriptSig &lt;&lt; bnNonce;<br />&nbsp; &nbsp; &nbsp; &nbsp; txNew.vout.resize(1);<br />&nbsp; &nbsp; &nbsp; &nbsp; txNew.vout[0].scriptPubKey &lt;&lt; OP_CODESEPARATOR &lt;&lt; keyUser.GetPubKey() &lt;&lt; OP_CHECKSIG;<br />&nbsp; &nbsp; &nbsp; &nbsp; txNew.vout[0].posNext.SetNull();<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Create new block<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; auto_ptr&lt;CBlock&gt; pblock(new CBlock());<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!pblock.get())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Add our coinbase tx as first transaction<br />&nbsp; &nbsp; &nbsp; &nbsp; pblock-&gt;vtx.push_back(txNew);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Collect the latest transactions into the block<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nFees = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapTransactions)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTxDB txdb(&quot;r&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set&lt;uint256&gt; setInThisBlock;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;char&gt; vfAlreadyAdded(mapTransactions.size());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fFoundSomething = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nSize = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (fFoundSomething &amp;&amp; nSize &lt; MAX_SIZE/2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fFoundSomething = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int n = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;uint256, CTransaction&gt;::iterator mi = mapTransactions.begin(); mi != mapTransactions.end(); ++mi, ++n)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vfAlreadyAdded[n])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; tx = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!tx.IsFinal() || tx.IsCoinBase())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Find if all dependencies are in this or previous blocks<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fHaveAllPrev = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nValueIn = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxIn&amp; txin, tx.vin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COutPoint prevout = txin.prevout;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CTransaction txPrev;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (setInThisBlock.count(prevout.hash))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txPrev = mapTransactions[prevout.hash];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (!txdb.ReadDiskTx(prevout.hash, txPrev))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fHaveAllPrev = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (prevout.n &gt;= txPrev.vout.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fHaveAllPrev = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nValueIn += txPrev.vout[prevout.n].nValue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 nTransactionFee = nValueIn - tx.GetValueOut();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nTransactionFee &lt; 0) // could require a tx fee here<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Add tx to block<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fHaveAllPrev)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fFoundSomething = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pblock-&gt;vtx.push_back(tx);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSize += ::GetSerializeSize(tx, SER_NETWORK);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFees += nTransactionFee;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vfAlreadyAdded[n] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setInThisBlock.insert(tx.GetHash());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Update last few things<br />&nbsp; &nbsp; &nbsp; &nbsp; pblock-&gt;vtx[0].vout[0].nValue = GetBlockValue(nFees);<br />&nbsp; &nbsp; &nbsp; &nbsp; pblock-&gt;hashMerkleRoot = pblock-&gt;BuildMerkleTree();<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n\nRunning BitcoinMiner with %d transactions in block\n&quot;, pblock-&gt;vtx.size());<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Prebuild hash buffer<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; struct unnamed1<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct unnamed2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 hashPrevBlock;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 hashMerkleRoot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTime;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBits;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nNonce;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned char pchPadding0[64];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint256 hash1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned char pchPadding1[64];<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; const CBlockIndex* pindexPrev = pindexBest;<br />&nbsp; &nbsp; &nbsp; &nbsp; tmp.block.hashPrevBlock = pblock-&gt;hashPrevBlock = hashTimeChainBest;<br />&nbsp; &nbsp; &nbsp; &nbsp; tmp.block.hashMerkleRoot = pblock-&gt;hashMerkleRoot;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Get time of previous block<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pindexPrev)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (blockPrev.GetHash() != pblock-&gt;hashPrevBlock)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockPrev.ReadFromDisk(pindexPrev, false);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (blockPrev.GetHash() != pblock-&gt;hashPrevBlock)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;pindexBest and hashTimeChainBest out of sync\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; tmp.block.nTime = pblock-&gt;nTime = max(blockPrev.nTime+1, (unsigned int)GetAdjustedTime());<br />&nbsp; &nbsp; &nbsp; &nbsp; tmp.block.nBits = pblock-&gt;nBits = GetNextWorkRequired(pindexPrev);<br />&nbsp; &nbsp; &nbsp; &nbsp; tmp.block.nNonce = 1;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBlocks0 = FormatHashBlocks(&amp;tmp.block, sizeof(tmp.block));<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nBlocks1 = FormatHashBlocks(&amp;tmp.hash1, sizeof(tmp.hash1));<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Search<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashTarget = (~uint256(0) &gt;&gt; pblock-&gt;nBits);<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hash;<br />&nbsp; &nbsp; &nbsp; &nbsp; while (nTransactionsUpdated == nTransactionsUpdatedLast)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockSHA256(&amp;tmp.block, nBlocks0, &amp;tmp.hash1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockSHA256(&amp;tmp.hash1, nBlocks1, &amp;hash);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash &lt;= hashTarget)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pblock-&gt;nNonce = tmp.block.nNonce;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(hash == pblock-&gt;GetHash());<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;BitcoinMiner:\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;supercoin found&nbsp; \n&nbsp; hash: %s&nbsp; \ntarget: %s\n&quot;, hash.GetHex().c_str(), hashTarget.GetHex().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pblock-&gt;print();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Process this block the same as if we had received it from another node<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!ProcessBlock(NULL, pblock.release()))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR in BitcoinMiner, ProcessBlock, block not accepted\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Update nTime every few seconds<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((++tmp.block.nNonce &amp; 0xfffff) == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tmp.block.nNonce == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp.block.nTime = pblock-&gt;nTime = max(blockPrev.nTime+1, (unsigned int)GetAdjustedTime());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// Actions<br />//<br /><br /><br />int64 CountMoney()<br />{<br />&nbsp; &nbsp; int64 nTotal = 0;<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;uint256, CWalletTx&gt;::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CWalletTx* pcoin = &amp;(*it).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pcoin-&gt;IsFinal() || pcoin-&gt;fSpent)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTotal += pcoin-&gt;GetCredit();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return nTotal;<br />}<br /><br /><br /><br />bool SelectCoins(int64 nTargetValue, set&lt;CWalletTx*&gt;&amp; setCoinsRet)<br />{<br />&nbsp; &nbsp; setCoinsRet.clear();<br /><br />&nbsp; &nbsp; // List of values less than target<br />&nbsp; &nbsp; int64 nLowestLarger = _I64_MAX;<br />&nbsp; &nbsp; CWalletTx* pcoinLowestLarger = NULL;<br />&nbsp; &nbsp; vector&lt;pair&lt;int64, CWalletTx*&gt; &gt; vValue;<br />&nbsp; &nbsp; int64 nTotalLower = 0;<br /><br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapWallet)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;uint256, CWalletTx&gt;::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CWalletTx* pcoin = &amp;(*it).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pcoin-&gt;IsFinal() || pcoin-&gt;fSpent)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 n = pcoin-&gt;GetCredit();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n &lt; nTargetValue)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vValue.push_back(make_pair(n, pcoin));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTotalLower += n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (n == nTargetValue)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setCoinsRet.insert(pcoin);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (n &lt; nLowestLarger)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nLowestLarger = n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcoinLowestLarger = pcoin;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (nTotalLower &lt; nTargetValue)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pcoinLowestLarger == NULL)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; setCoinsRet.insert(pcoinLowestLarger);<br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Solve subset sum by stochastic approximation<br />&nbsp; &nbsp; sort(vValue.rbegin(), vValue.rend());<br />&nbsp; &nbsp; vector&lt;char&gt; vfIncluded;<br />&nbsp; &nbsp; vector&lt;char&gt; vfBest(vValue.size(), true);<br />&nbsp; &nbsp; int64 nBest = nTotalLower;<br /><br />&nbsp; &nbsp; for (int nRep = 0; nRep &lt; 1000 &amp;&amp; nBest != nTargetValue; nRep++)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vfIncluded.assign(vValue.size(), false);<br />&nbsp; &nbsp; &nbsp; &nbsp; int64 nTotal = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vValue.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rand() % 2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTotal += vValue[i].first;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vfIncluded[i] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nTotal &gt;= nTargetValue)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nTotal &lt; nBest)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nBest = nTotal;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vfBest = vfIncluded;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTotal -= vValue[i].first;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vfIncluded[i] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // If the next larger is still closer, return it<br />&nbsp; &nbsp; if (pcoinLowestLarger &amp;&amp; nLowestLarger - nTargetValue &lt;= nBest - nTargetValue)<br />&nbsp; &nbsp; &nbsp; &nbsp; setCoinsRet.insert(pcoinLowestLarger);<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; vValue.size(); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (vfBest[i])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setCoinsRet.insert(vValue[i].second);<br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br />bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew)<br />{<br />&nbsp; &nbsp; wtxNew.vin.clear();<br />&nbsp; &nbsp; wtxNew.vout.clear();<br />&nbsp; &nbsp; if (nValue &lt; TRANSACTIONFEE)<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Choose coins to use<br />&nbsp; &nbsp; set&lt;CWalletTx*&gt; setCoins;<br />&nbsp; &nbsp; if (!SelectCoins(nValue, setCoins))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; int64 nValueIn = 0;<br />&nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins)<br />&nbsp; &nbsp; &nbsp; &nbsp; nValueIn += pcoin-&gt;GetCredit();<br /><br />&nbsp; &nbsp; // Fill vout[0] to the payee<br />&nbsp; &nbsp; int64 nValueOut = nValue - TRANSACTIONFEE;<br />&nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey));<br /><br />&nbsp; &nbsp; // Fill vout[1] back to self with any change<br />&nbsp; &nbsp; if (nValueIn - TRANSACTIONFEE &gt; nValueOut)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Use the same key as one of the coins<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned char&gt; vchPubKey;<br />&nbsp; &nbsp; &nbsp; &nbsp; CTransaction&amp; txFirst = *(*setCoins.begin());<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(const CTxOut&amp; txout, txFirst.vout)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (txout.IsMine())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vchPubKey.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Fill vout[1] to ourself<br />&nbsp; &nbsp; &nbsp; &nbsp; CScript scriptPubKey;<br />&nbsp; &nbsp; &nbsp; &nbsp; scriptPubKey &lt;&lt; OP_CODESEPARATOR &lt;&lt; vchPubKey &lt;&lt; OP_CHECKSIG;<br />&nbsp; &nbsp; &nbsp; &nbsp; wtxNew.vout.push_back(CTxOut(nValueIn - TRANSACTIONFEE - nValueOut, scriptPubKey));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Fill vin<br />&nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins)<br />&nbsp; &nbsp; &nbsp; &nbsp; for (int nOut = 0; nOut &lt; pcoin-&gt;vout.size(); nOut++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pcoin-&gt;vout[nOut].IsMine())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SignSignature(*pcoin, nOut, wtxNew, -1, &quot;all&quot;);<br /><br />&nbsp; &nbsp; // Fill vtxPrev by copying from previous transactions vtxPrev<br />&nbsp; &nbsp; wtxNew.AddSupportingTransactions();<br /><br />&nbsp; &nbsp; // Add tx to wallet, because if it has change it&#039;s also ours,<br />&nbsp; &nbsp; // otherwise just for transaction history.<br />&nbsp; &nbsp; wtxNew.nTime = GetAdjustedTime();<br />&nbsp; &nbsp; AddToWallet(wtxNew);<br /><br />&nbsp; &nbsp; // Mark old coins as spent<br />&nbsp; &nbsp; foreach(CWalletTx* pcoin, setCoins)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; pcoin-&gt;fSpent = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; pcoin-&gt;WriteToDisk();<br />&nbsp; &nbsp; &nbsp; &nbsp; vWalletUpdated.push_back(make_pair(pcoin-&gt;GetHash(), false));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br /><br /><br />bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx&amp; wtxNew)<br />{<br />&nbsp; &nbsp; if (!CreateTransaction(scriptPubKey, nValue, wtxNew))<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; // Broadcast<br />&nbsp; &nbsp; if (!wtxNew.AcceptTransaction())<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // This must not fail. The transaction has already been signed and recorded.<br />&nbsp; &nbsp; &nbsp; &nbsp; throw runtime_error(&quot;SendMoney() : wtxNew.AcceptTransaction() failed\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; wtxNew.RelayWalletTransaction();<br /><br />&nbsp; &nbsp; return true;<br />}<br /></div>[/pre]</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:35:15 PM</b>
					<hr />
					<div style="margin: 0 5ex;">This is the contents of the file node.h. <br /><br /><pre></pre><div class="codeheader">Code:</div><div class="code">// Copyright (c) 2008 Satoshi Nakamoto<br />//<br />// Permission is hereby granted, free of charge, to any person obtaining a copy<br />// of this software and associated documentation files (the &quot;Software&quot;), to deal<br />// in the Software without restriction, including without limitation the rights<br />// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br />// copies of the Software, and to permit persons to whom the Software is<br />// furnished to do so, subject to the following conditions:<br />//<br />// The above copyright notice and this permission notice shall be included in<br />// all copies or substantial portions of the Software.<br />//<br />// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br />// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br />// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT<br />// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR<br />// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br />// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br />// IN THE SOFTWARE.<br /><br />class CMessageHeader;<br />class CAddress;<br />class CInv;<br />class CRequestTracker;<br />class CNode;<br /><br /><br /><br />static const unsigned short DEFAULT_PORT = htons(2222);<br />static const unsigned int BROADCAST_HOPS = 5;<br />enum<br />{<br />&nbsp; &nbsp; NODE_NETWORK = (1 &lt;&lt; 0),<br />};<br /><br /><br /><br /><br /><br /><br /><br />bool AddAddress(CAddrDB&amp; addrdb, const CAddress&amp; addr);<br />CNode* FindNode(unsigned int ip);<br />CNode* ConnectNode(CAddress addrConnect, int64 nTimeout=0);<br />void AbandonRequests(void (*fn)(void*, CDataStream&amp;), void* param1);<br />bool AnySubscribed(unsigned int nChannel);<br />void ThreadBitcoinMiner(void* parg);<br />bool StartNode(string&amp; strError=REF(string()));<br />bool StopNode();<br />void CheckForShutdown(int n);<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//<br />// Message header<br />//&nbsp; (4) message start<br />//&nbsp; (12) command<br />//&nbsp; (4) size<br /><br />// The message start string is designed to be unlikely to occur in normal data.<br />// The characters are rarely used upper ascii, not valid as UTF-8, and produce<br />// a large 4-byte int at any alignment.<br />static const char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };<br /><br />class CMessageHeader<br />{<br />public:<br />&nbsp; &nbsp; enum { COMMAND_SIZE=12 };<br />&nbsp; &nbsp; char pchMessageStart[sizeof(::pchMessageStart)];<br />&nbsp; &nbsp; char pchCommand[COMMAND_SIZE];<br />&nbsp; &nbsp; unsigned int nMessageSize;<br /><br />&nbsp; &nbsp; CMessageHeader()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));<br />&nbsp; &nbsp; &nbsp; &nbsp; memset(pchCommand, 0, sizeof(pchCommand));<br />&nbsp; &nbsp; &nbsp; &nbsp; pchCommand[1] = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; nMessageSize = -1;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));<br />&nbsp; &nbsp; &nbsp; &nbsp; strncpy(pchCommand, pszCommand, COMMAND_SIZE);<br />&nbsp; &nbsp; &nbsp; &nbsp; nMessageSize = nMessageSizeIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(FLATDATA(pchMessageStart));<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(FLATDATA(pchCommand));<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nMessageSize);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; string GetCommand()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pchCommand[COMMAND_SIZE-1] == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return string(pchCommand, pchCommand + strlen(pchCommand));<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return string(pchCommand, pchCommand + COMMAND_SIZE);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsValid()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Check start string<br />&nbsp; &nbsp; &nbsp; &nbsp; if (memcmp(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart)) != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Check the command string for errors<br />&nbsp; &nbsp; &nbsp; &nbsp; for (char* p1 = pchCommand; p1 &lt; pchCommand + COMMAND_SIZE; p1++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (*p1 == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Must be all zeros after the first zero<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (; p1 &lt; pchCommand + COMMAND_SIZE; p1++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (*p1 != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (*p1 &lt; &#039; &#039; || *p1 &gt; 0x7E)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Message size<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nMessageSize &gt; 0x10000000)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CMessageHeader::IsValid() : nMessageSize too large %u\n&quot;, nMessageSize);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br /><br /><br /><br />static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };<br /><br />class CAddress<br />{<br />public:<br />&nbsp; &nbsp; uint64 nServices;<br />&nbsp; &nbsp; unsigned char pchReserved[12];<br />&nbsp; &nbsp; unsigned int ip;<br />&nbsp; &nbsp; unsigned short port;<br /><br />&nbsp; &nbsp; // disk only<br />&nbsp; &nbsp; unsigned int nTime;<br /><br />&nbsp; &nbsp; CAddress()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nServices = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pchReserved, pchIPv4, sizeof(pchReserved));<br />&nbsp; &nbsp; &nbsp; &nbsp; ip = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; port = DEFAULT_PORT;<br />&nbsp; &nbsp; &nbsp; &nbsp; nTime = GetAdjustedTime();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CAddress(unsigned int ipIn, unsigned short portIn, uint64 nServicesIn=0)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nServices = nServicesIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pchReserved, pchIPv4, sizeof(pchReserved));<br />&nbsp; &nbsp; &nbsp; &nbsp; ip = ipIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; port = portIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nTime = GetAdjustedTime();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; explicit CAddress(const char* pszIn, uint64 nServicesIn=0)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nServices = nServicesIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pchReserved, pchIPv4, sizeof(pchReserved));<br />&nbsp; &nbsp; &nbsp; &nbsp; ip = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; port = DEFAULT_PORT;<br />&nbsp; &nbsp; &nbsp; &nbsp; nTime = GetAdjustedTime();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; char psz[100];<br />&nbsp; &nbsp; &nbsp; &nbsp; if (strlen(pszIn) &gt; ARRAYLEN(psz)-1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; strcpy(psz, pszIn);<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int a, b, c, d, e;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (sscanf(psz, &quot;%u.%u.%u.%u:%u&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e) &lt; 4)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; char* pszPort = strchr(psz, &#039;:&#039;);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (pszPort)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pszPort++ = &#039;\0&#039;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port = htons(atoi(pszPort));<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; ip = inet_addr(psz);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nType &amp; SER_DISK)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nVersion);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nTime);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(nServices);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(FLATDATA(pchReserved));<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(ip);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(port);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; friend inline bool operator==(const CAddress&amp; a, const CAddress&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved)) == 0 &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.ip&nbsp; &nbsp;== b.ip &amp;&amp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.port == b.port);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; friend inline bool operator&lt;(const CAddress&amp; a, const CAddress&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int ret = memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved));<br />&nbsp; &nbsp; &nbsp; &nbsp; if (ret &lt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; else if (ret == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ntohl(a.ip) &lt; ntohl(b.ip))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (a.ip == b.ip)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ntohs(a.port) &lt; ntohs(b.port);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; vector&lt;unsigned char&gt; GetKey() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CDataStream ss;<br />&nbsp; &nbsp; &nbsp; &nbsp; ss &lt;&lt; FLATDATA(pchReserved) &lt;&lt; ip &lt;&lt; port;<br />&nbsp; &nbsp; &nbsp; &nbsp; return vector&lt;unsigned char&gt;((unsigned char*)&amp;ss.begin()[0], (unsigned char*)&amp;ss.end()[0]);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsIPv4() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (memcmp(pchReserved, pchIPv4, sizeof(pchIPv4)) == 0);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; unsigned char GetByte(int n) const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return ((unsigned char*)&amp;ip)[3-n];<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; string ToString() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return strprintf(&quot;%u.%u.%u.%u:%u&quot;, GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CAddress(%s)\n&quot;, ToString().c_str());<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br /><br /><br /><br />enum<br />{<br />&nbsp; &nbsp; MSG_TX = 1,<br />&nbsp; &nbsp; MSG_BLOCK,<br />&nbsp; &nbsp; MSG_REVIEW,<br />&nbsp; &nbsp; MSG_PRODUCT,<br />&nbsp; &nbsp; MSG_TABLE,<br />};<br /><br />static const char* ppszTypeName&#91;] =<br />{<br />&nbsp; &nbsp; &quot;ERROR&quot;,<br />&nbsp; &nbsp; &quot;tx&quot;,<br />&nbsp; &nbsp; &quot;block&quot;,<br />&nbsp; &nbsp; &quot;review&quot;,<br />&nbsp; &nbsp; &quot;product&quot;,<br />&nbsp; &nbsp; &quot;table&quot;,<br />};<br /><br />class CInv<br />{<br />public:<br />&nbsp; &nbsp; int type;<br />&nbsp; &nbsp; uint256 hash;<br /><br />&nbsp; &nbsp; CInv()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; type = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; hash = 0;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CInv(int typeIn, const uint256&amp; hashIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; type = typeIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; hash = hashIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; CInv(const string&amp; strType, const uint256&amp; hashIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; &nbsp; for (i = 1; i &lt; ARRAYLEN(ppszTypeName); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (strType == ppszTypeName[i])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; if (i == ARRAYLEN(ppszTypeName))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw std::out_of_range(strprintf(&quot;CInv::CInv(string, uint256) : unknown type &#039;%s&#039;&quot;, strType.c_str()));<br />&nbsp; &nbsp; &nbsp; &nbsp; hash = hashIn;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; IMPLEMENT_SERIALIZE<br />&nbsp; &nbsp; (<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(type);<br />&nbsp; &nbsp; &nbsp; &nbsp; READWRITE(hash);<br />&nbsp; &nbsp; )<br /><br />&nbsp; &nbsp; friend inline bool operator&lt;(const CInv&amp; a, const CInv&amp; b)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (a.type &lt; b.type || (a.type == b.type &amp;&amp; a.hash &lt; b.hash));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsKnownType() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return (type &gt;= 1 &amp;&amp; type &lt; ARRAYLEN(ppszTypeName));<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; const char* GetCommand() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (!IsKnownType())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw std::out_of_range(strprintf(&quot;CInv::GetCommand() : type=% unknown type&quot;, type));<br />&nbsp; &nbsp; &nbsp; &nbsp; return ppszTypeName[type];<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; string ToString() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return strprintf(&quot;%s %s&quot;, GetCommand(), hash.ToString().substr(0,6).c_str());<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void print() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;CInv(%s)\n&quot;, ToString().c_str());<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br /><br />class CRequestTracker<br />{<br />public:<br />&nbsp; &nbsp; void (*fn)(void*, CDataStream&amp;);<br />&nbsp; &nbsp; void* param1;<br /><br />&nbsp; &nbsp; explicit CRequestTracker(void (*fnIn)(void*, CDataStream&amp;)=NULL, void* param1In=NULL)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; fn = fnIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; param1 = param1In;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; bool IsNull()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return fn == NULL;<br />&nbsp; &nbsp; }<br />};<br /><br /><br /><br /><br /><br />extern bool fClient;<br />extern uint64 nLocalServices;<br />extern CAddress addrLocalHost;<br />extern CNode* pnodeLocalHost;<br />extern bool fShutdown;<br />extern array&lt;bool, 10&gt; vfThreadRunning;<br />extern vector&lt;CNode*&gt; vNodes;<br />extern CCriticalSection cs_vNodes;<br />extern map&lt;vector&lt;unsigned char&gt;, CAddress&gt; mapAddresses;<br />extern CCriticalSection cs_mapAddresses;<br />extern map&lt;CInv, CDataStream&gt; mapRelay;<br />extern deque&lt;pair&lt;int64, CInv&gt; &gt; vRelayExpiration;<br />extern CCriticalSection cs_mapRelay;<br />extern map&lt;CInv, int64&gt; mapAlreadyAskedFor;<br /><br /><br /><br /><br /><br />class CNode<br />{<br />public:<br />&nbsp; &nbsp; // socket<br />&nbsp; &nbsp; uint64 nServices;<br />&nbsp; &nbsp; SOCKET hSocket;<br />&nbsp; &nbsp; CDataStream vSend;<br />&nbsp; &nbsp; CDataStream vRecv;<br />&nbsp; &nbsp; CCriticalSection cs_vSend;<br />&nbsp; &nbsp; CCriticalSection cs_vRecv;<br />&nbsp; &nbsp; unsigned int nPushPos;<br />&nbsp; &nbsp; CAddress addr;<br />&nbsp; &nbsp; int nVersion;<br />&nbsp; &nbsp; bool fClient;<br />&nbsp; &nbsp; bool fInbound;<br />&nbsp; &nbsp; bool fNetworkNode;<br />&nbsp; &nbsp; bool fDisconnect;<br />protected:<br />&nbsp; &nbsp; int nRefCount;<br />public:<br />&nbsp; &nbsp; int64 nReleaseTime;<br />&nbsp; &nbsp; map&lt;uint256, CRequestTracker&gt; mapRequests;<br />&nbsp; &nbsp; CCriticalSection cs_mapRequests;<br /><br />&nbsp; &nbsp; // flood<br />&nbsp; &nbsp; vector&lt;CAddress&gt; vAddrToSend;<br />&nbsp; &nbsp; set&lt;CAddress&gt; setAddrKnown;<br /><br />&nbsp; &nbsp; // inventory based relay<br />&nbsp; &nbsp; vector&lt;CInv&gt; vInventoryToSend;<br />&nbsp; &nbsp; set&lt;CInv&gt; setInventoryKnown;<br />&nbsp; &nbsp; CCriticalSection cs_inventory;<br />&nbsp; &nbsp; multimap&lt;int64, CInv&gt; mapAskFor;<br /><br />&nbsp; &nbsp; // broadcast and subscription<br />&nbsp; &nbsp; vector&lt;char&gt; vfSubscribe;<br /><br /><br />&nbsp; &nbsp; CNode(SOCKET hSocketIn, CAddress addrIn)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nServices = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; hSocket = hSocketIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; vSend.SetType(SER_NETWORK);<br />&nbsp; &nbsp; &nbsp; &nbsp; vRecv.SetType(SER_NETWORK);<br />&nbsp; &nbsp; &nbsp; &nbsp; nPushPos = -1;<br />&nbsp; &nbsp; &nbsp; &nbsp; addr = addrIn;<br />&nbsp; &nbsp; &nbsp; &nbsp; nVersion = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; fClient = false; // set by version message<br />&nbsp; &nbsp; &nbsp; &nbsp; fInbound = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; fNetworkNode = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; fDisconnect = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; nRefCount = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; nReleaseTime = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; vfSubscribe.assign(256, false);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Push a version message<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nTime = GetAdjustedTime();<br />&nbsp; &nbsp; &nbsp; &nbsp; PushMessage(&quot;version&quot;, VERSION, nLocalServices, nTime);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; ~CNode()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (hSocket != INVALID_SOCKET)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; closesocket(hSocket);<br />&nbsp; &nbsp; }<br /><br />private:<br />&nbsp; &nbsp; CNode(const CNode&amp;);<br />&nbsp; &nbsp; void operator=(const CNode&amp;);<br />public:<br /><br /><br />&nbsp; &nbsp; bool ReadyToDisconnect()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return fDisconnect || GetRefCount() &lt;= 0;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; int GetRefCount()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; return max(nRefCount, 0) + (GetTime() &lt; nReleaseTime ? 1 : 0);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void AddRef(int64 nTimeout=0)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nTimeout != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nReleaseTime = max(nReleaseTime, GetTime() + nTimeout);<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nRefCount++;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void Release()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; nRefCount--;<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; void AddInventoryKnown(const CInv&amp; inv)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_inventory)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setInventoryKnown.insert(inv);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void AskFor(const CInv&amp; inv)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // We&#039;re using mapAskFor as a priority queue,<br />&nbsp; &nbsp; &nbsp; &nbsp; // the key is the earliest time the request can be sent<br />&nbsp; &nbsp; &nbsp; &nbsp; int64&amp; nRequestTime = mapAlreadyAskedFor[inv];<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;askfor %s&nbsp; %I64d\n&quot;, inv.ToString().c_str(), nRequestTime);<br />&nbsp; &nbsp; &nbsp; &nbsp; nRequestTime = max(nRequestTime + 2 * 60, GetTime());<br />&nbsp; &nbsp; &nbsp; &nbsp; mapAskFor.insert(make_pair(nRequestTime, inv));<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; void BeginMessage(const char* pszCommand)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; EnterCriticalSection(&amp;cs_vSend);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nPushPos != -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; nPushPos = vSend.size();<br />&nbsp; &nbsp; &nbsp; &nbsp; vSend &lt;&lt; CMessageHeader(pszCommand, 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;sending: %-12s &quot;, pszCommand);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void AbortMessage()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nPushPos == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; vSend.resize(nPushPos);<br />&nbsp; &nbsp; &nbsp; &nbsp; nPushPos = -1;<br />&nbsp; &nbsp; &nbsp; &nbsp; LeaveCriticalSection(&amp;cs_vSend);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;(aborted)\n&quot;);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void EndMessage()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nPushPos == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Patch in the size<br />&nbsp; &nbsp; &nbsp; &nbsp; unsigned int nSize = vSend.size() - nPushPos - sizeof(CMessageHeader);<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy((char*)&amp;vSend[nPushPos] + offsetof(CMessageHeader, nMessageSize), &amp;nSize, sizeof(nSize));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;(%d bytes)&nbsp; &quot;, nSize);<br />&nbsp; &nbsp; &nbsp; &nbsp; //for (int i = nPushPos+sizeof(CMessageHeader); i &lt; min(vSend.size(), nPushPos+sizeof(CMessageHeader)+20U); i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; printf(&quot;%02x &quot;, vSend[i] &amp; 0xff);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; nPushPos = -1;<br />&nbsp; &nbsp; &nbsp; &nbsp; LeaveCriticalSection(&amp;cs_vSend);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; void EndMessageAbortIfEmpty()<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nPushPos == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;<br />&nbsp; &nbsp; &nbsp; &nbsp; int nSize = vSend.size() - nPushPos - sizeof(CMessageHeader);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nSize &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; const char* GetMessageCommand() const<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nPushPos == -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &quot;&quot;;<br />&nbsp; &nbsp; &nbsp; &nbsp; return &amp;vSend[nPushPos] + offsetof(CMessageHeader, pchCommand);<br />&nbsp; &nbsp; }<br /><br /><br /><br /><br />&nbsp; &nbsp; void PushMessage(const char* pszCommand)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeginMessage(pszCommand);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; catch (...)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template&lt;typename T1&gt;<br />&nbsp; &nbsp; void PushMessage(const char* pszCommand, const T1&amp; a1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeginMessage(pszCommand);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSend &lt;&lt; a1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; catch (...)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template&lt;typename T1, typename T2&gt;<br />&nbsp; &nbsp; void PushMessage(const char* pszCommand, const T1&amp; a1, const T2&amp; a2)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeginMessage(pszCommand);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSend &lt;&lt; a1 &lt;&lt; a2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; catch (...)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template&lt;typename T1, typename T2, typename T3&gt;<br />&nbsp; &nbsp; void PushMessage(const char* pszCommand, const T1&amp; a1, const T2&amp; a2, const T3&amp; a3)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeginMessage(pszCommand);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSend &lt;&lt; a1 &lt;&lt; a2 &lt;&lt; a3;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; catch (...)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template&lt;typename T1, typename T2, typename T3, typename T4&gt;<br />&nbsp; &nbsp; void PushMessage(const char* pszCommand, const T1&amp; a1, const T2&amp; a2, const T3&amp; a3, const T4&amp; a4)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeginMessage(pszCommand);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSend &lt;&lt; a1 &lt;&lt; a2 &lt;&lt; a3 &lt;&lt; a4;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; catch (...)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AbortMessage();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; void PushRequest(const char* pszCommand,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void (*fn)(void*, CDataStream&amp;), void* param1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashReply;<br />&nbsp; &nbsp; &nbsp; &nbsp; RAND_bytes((unsigned char*)&amp;hashReply, sizeof(hashReply));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapRequests)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapRequests[hashReply] = CRequestTracker(fn, param1);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; PushMessage(pszCommand, hashReply);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template&lt;typename T1&gt;<br />&nbsp; &nbsp; void PushRequest(const char* pszCommand, const T1&amp; a1,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void (*fn)(void*, CDataStream&amp;), void* param1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashReply;<br />&nbsp; &nbsp; &nbsp; &nbsp; RAND_bytes((unsigned char*)&amp;hashReply, sizeof(hashReply));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapRequests)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapRequests[hashReply] = CRequestTracker(fn, param1);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; PushMessage(pszCommand, hashReply, a1);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template&lt;typename T1, typename T2&gt;<br />&nbsp; &nbsp; void PushRequest(const char* pszCommand, const T1&amp; a1, const T2&amp; a2,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void (*fn)(void*, CDataStream&amp;), void* param1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; uint256 hashReply;<br />&nbsp; &nbsp; &nbsp; &nbsp; RAND_bytes((unsigned char*)&amp;hashReply, sizeof(hashReply));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapRequests)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapRequests[hashReply] = CRequestTracker(fn, param1);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; PushMessage(pszCommand, hashReply, a1, a2);<br />&nbsp; &nbsp; }<br /><br /><br /><br />&nbsp; &nbsp; bool IsSubscribed(unsigned int nChannel);<br />&nbsp; &nbsp; void Subscribe(unsigned int nChannel, unsigned int nHops=0);<br />&nbsp; &nbsp; void CancelSubscribe(unsigned int nChannel);<br />&nbsp; &nbsp; void Disconnect();<br />};<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />inline void RelayInventory(const CInv&amp; inv)<br />{<br />&nbsp; &nbsp; // Put on lists to offer to the other nodes<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(pnode-&gt;cs_inventory)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pnode-&gt;setInventoryKnown.count(inv))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;vInventoryToSend.push_back(inv);<br />}<br /><br />template&lt;typename T&gt;<br />void RelayMessage(const CInv&amp; inv, const T&amp; a)<br />{<br />&nbsp; &nbsp; CDataStream ss(SER_NETWORK);<br />&nbsp; &nbsp; ss &lt;&lt; a;<br />&nbsp; &nbsp; RelayMessage(inv, ss);<br />}<br /><br />template&lt;&gt;<br />inline void RelayMessage&lt;&gt;(const CInv&amp; inv, const CDataStream&amp; ss)<br />{<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapRelay)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Save original serialized message so newer versions are preserved<br />&nbsp; &nbsp; &nbsp; &nbsp; mapRelay[inv] = ss;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Expire old relay messages<br />&nbsp; &nbsp; &nbsp; &nbsp; vRelayExpiration.push_back(make_pair(GetTime() + 10 * 60, inv));<br />&nbsp; &nbsp; &nbsp; &nbsp; while (!vRelayExpiration.empty() &amp;&amp; vRelayExpiration.front().first &lt; GetTime())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapRelay.erase(vRelayExpiration.front().second);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vRelayExpiration.pop_front();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; RelayInventory(inv);<br />}<br /></div>[/pre]</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:36:17 PM</b>
					<hr />
					<div style="margin: 0 5ex;">And here are the contents of the file node.cpp.<br /><br /><br /><pre></pre><div class="codeheader">Code:</div><div class="code">// Copyright (c) 2008 Satoshi Nakamoto<br />//<br />// Permission is hereby granted, free of charge, to any person obtaining a copy<br />// of this software and associated documentation files (the &quot;Software&quot;), to deal<br />// in the Software without restriction, including without limitation the rights<br />// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br />// copies of the Software, and to permit persons to whom the Software is<br />// furnished to do so, subject to the following conditions:<br />//<br />// The above copyright notice and this permission notice shall be included in<br />// all copies or substantial portions of the Software.<br />//<br />// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br />// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br />// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT<br />// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR<br />// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br />// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br />// IN THE SOFTWARE.<br /><br />#include &quot;headers.h&quot;<br />#include &lt;winsock2.h&gt;<br /><br />void ThreadMessageHandler2(void* parg);<br />void ThreadSocketHandler2(void* parg);<br />void ThreadOpenConnections2(void* parg);<br /><br /><br /><br /><br /><br /><br />//<br />// Global state variables<br />//<br />bool fClient = false;<br />uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);<br />CAddress addrLocalHost(0, DEFAULT_PORT, nLocalServices);<br />CNode nodeLocalHost(INVALID_SOCKET, CAddress(&quot;127.0.0.1&quot;, nLocalServices));<br />CNode* pnodeLocalHost = &amp;nodeLocalHost;<br />bool fShutdown = false;<br />array&lt;bool, 10&gt; vfThreadRunning;<br />vector&lt;CNode*&gt; vNodes;<br />CCriticalSection cs_vNodes;<br />map&lt;vector&lt;unsigned char&gt;, CAddress&gt; mapAddresses;<br />CCriticalSection cs_mapAddresses;<br />map&lt;CInv, CDataStream&gt; mapRelay;<br />deque&lt;pair&lt;int64, CInv&gt; &gt; vRelayExpiration;<br />CCriticalSection cs_mapRelay;<br />map&lt;CInv, int64&gt; mapAlreadyAskedFor;<br /><br /><br /><br /><br /><br /><br />bool AddAddress(CAddrDB&amp; addrdb, const CAddress&amp; addr)<br />{<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapAddresses)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; map&lt;vector&lt;unsigned char&gt;, CAddress&gt;::iterator it = mapAddresses.find(addr.GetKey());<br />&nbsp; &nbsp; &nbsp; &nbsp; if (it == mapAddresses.end())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // New address<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapAddresses.insert(make_pair(addr.GetKey(), addr));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrdb.WriteAddress(addr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAddress&amp; addrFound = (*it).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((addrFound.nServices | addr.nServices) != addrFound.nServices)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Services have been added<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrFound.nServices |= addr.nServices;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrdb.WriteAddress(addrFound);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return false;<br />}<br /><br /><br /><br /><br /><br />void AbandonRequests(void (*fn)(void*, CDataStream&amp;), void* param1)<br />{<br />&nbsp; &nbsp; // If the dialog might get closed before the reply comes back,<br />&nbsp; &nbsp; // call this in the destructor so it doesn&#039;t get called after it&#039;s deleted.<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(pnode-&gt;cs_mapRequests)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;uint256, CRequestTracker&gt;::iterator mi = pnode-&gt;mapRequests.begin(); mi != pnode-&gt;mapRequests.end();)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRequestTracker&amp; tracker = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tracker.fn == fn &amp;&amp; tracker.param1 == param1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;mapRequests.erase(mi++);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mi++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />CNode* FindNode(unsigned int ip)<br />{<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;addr.ip == ip)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (pnode);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return NULL;<br />}<br /><br />CNode* FindNode(CAddress addr)<br />{<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;addr == addr)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (pnode);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return NULL;<br />}<br /><br />CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)<br />{<br />&nbsp; &nbsp; if (addrConnect.ip == addrLocalHost.ip)<br />&nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br /><br />&nbsp; &nbsp; // Look for an existing connection<br />&nbsp; &nbsp; CNode* pnode = FindNode(addrConnect.ip);<br />&nbsp; &nbsp; if (pnode)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nTimeout != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef(nTimeout);<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef();<br />&nbsp; &nbsp; &nbsp; &nbsp; return pnode;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Connect<br />&nbsp; &nbsp; SOCKET hSocket = socket(AF_INET, SOCK_STREAM, 0);<br />&nbsp; &nbsp; if (hSocket == INVALID_SOCKET)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;socket failed\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; struct sockaddr_in sockaddr;<br />&nbsp; &nbsp; sockaddr.sin_family = AF_INET;<br />&nbsp; &nbsp; sockaddr.sin_addr.s_addr = addrConnect.ip;<br />&nbsp; &nbsp; sockaddr.sin_port = addrConnect.port;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; /// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; static map&lt;unsigned int, unsigned int&gt; mapPrintLimit;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (mapPrintLimit[addrConnect.ip] % 20 == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;connecting to %d.%d.%d.%d\n&quot;, ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[0], ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[1], ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[2], ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[3]);<br /><br />&nbsp; &nbsp; if (connect(hSocket, (struct sockaddr*)&amp;sockaddr, sizeof(sockaddr)) != SOCKET_ERROR)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapPrintLimit[addrConnect.ip] = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;connected %d.%d.%d.%d\n&quot;, ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[0], ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[1], ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[2], ((unsigned char*)&amp;sockaddr.sin_addr.s_addr)[3]);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Add node<br />&nbsp; &nbsp; &nbsp; &nbsp; CNode* pnode = new CNode(hSocket, addrConnect);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nTimeout != 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef(nTimeout);<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef();<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodes.push_back(pnode);<br />&nbsp; &nbsp; &nbsp; &nbsp; return pnode;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; //// todo: need to set last failed connect time, and increment a failed to connect counter<br />&nbsp; &nbsp; &nbsp; &nbsp; /// debug print<br />&nbsp; &nbsp; &nbsp; &nbsp; if ((mapPrintLimit[addrConnect.ip]++) % 20 == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;connection failed %d\n&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; return NULL;<br />&nbsp; &nbsp; }<br />}<br /><br />void CNode::Disconnect()<br />{<br />&nbsp; &nbsp; printf(&quot;disconnecting node %s\n&quot;, addr.ToString().c_str());<br /><br />&nbsp; &nbsp; closesocket(hSocket);<br /><br />&nbsp; &nbsp; // All of a nodes broadcasts and subscriptions are automatically torn down<br />&nbsp; &nbsp; // when it goes down, so a node has to stay up to keep its broadcast going.<br /><br />&nbsp; &nbsp; // Cancel and delete unsourced broadcasts<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapTables)<br />&nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;uint256, CTable&gt;::iterator mi = mapTables.begin(); mi != mapTables.end();)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AdvertRemoveSource(this, MSG_TABLE, 0, (*(mi++)).second);<br />&nbsp; &nbsp; CRITICAL_BLOCK(cs_mapProducts)<br />&nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;uint256, CProduct&gt;::iterator mi = mapProducts.begin(); mi != mapProducts.end();)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AdvertRemoveSource(this, MSG_PRODUCT, 0, (*(mi++)).second);<br /><br />&nbsp; &nbsp; // Cancel subscriptions<br />&nbsp; &nbsp; for (unsigned int nChannel = 0; nChannel &lt; vfSubscribe.size(); nChannel++)<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vfSubscribe[nChannel])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CancelSubscribe(nChannel);<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />void ThreadSocketHandler(void* parg)<br />{<br />&nbsp; &nbsp; IMPLEMENT_RANDOMIZE_STACK(ThreadSocketHandler(parg));<br /><br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[0] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(0);<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThreadSocketHandler2(parg);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; CATCH_PRINT_EXCEPTION(&quot;ThreadSocketHandler()&quot;)<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[0] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(5000);<br />&nbsp; &nbsp; }<br />}<br /><br />void ThreadSocketHandler2(void* parg)<br />{<br />&nbsp; &nbsp; printf(&quot;ThreadSocketHandler started\n&quot;);<br />&nbsp; &nbsp; SOCKET hListenSocket = *(SOCKET*)parg;<br />&nbsp; &nbsp; list&lt;CNode*&gt; vNodesDisconnected;<br />&nbsp; &nbsp; int nPrevNodeCount = 0;<br /><br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Disconnect nodes<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Disconnect duplicate connections<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;unsigned int, CNode*&gt; mapFirst;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int ip = pnode-&gt;addr.ip;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (mapFirst.count(ip) &amp;&amp; addrLocalHost.ip &lt; ip)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // In case two nodes connect to each other at once,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the lower ip disconnects its outbound connection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CNode* pnodeExtra = mapFirst[ip];<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnodeExtra-&gt;GetRefCount() &gt; (pnodeExtra-&gt;fNetworkNode ? 1 : 0))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(pnodeExtra, pnode);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnodeExtra-&gt;GetRefCount() &lt;= (pnodeExtra-&gt;fNetworkNode ? 1 : 0))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;(%d nodes) disconnecting duplicate: %s&quot;, vNodes.size(), pnodeExtra-&gt;addr.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnodeExtra-&gt;fNetworkNode &amp;&amp; !pnode-&gt;fNetworkNode)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(pnodeExtra-&gt;fNetworkNode, pnode-&gt;fNetworkNode);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnodeExtra-&gt;Release();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnodeExtra-&gt;fDisconnect = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapFirst[ip] = pnode;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Disconnect unused nodes<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CNode*&gt; vNodesCopy = vNodes;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodesCopy)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;ReadyToDisconnect() &amp;&amp; pnode-&gt;vRecv.empty() &amp;&amp; pnode-&gt;vSend.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // remove from vNodes<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;Disconnect();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // hold in disconnected pool until all refs are released<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;nReleaseTime = max(pnode-&gt;nReleaseTime, GetTime() + 5 * 60);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;fNetworkNode)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;Release();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodesDisconnected.push_back(pnode);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Delete disconnected nodes<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list&lt;CNode*&gt; vNodesDisconnectedCopy = vNodesDisconnected;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodesDisconnectedCopy)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // wait until threads are done using it<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;GetRefCount() &lt;= 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fDelete = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_vSend)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TRY_CRITICAL_BLOCK(pnode-&gt;cs_vRecv)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_mapRequests)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TRY_CRITICAL_BLOCK(pnode-&gt;cs_inventory)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fDelete = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (fDelete)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodesDisconnected.remove(pnode);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete pnode;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vNodes.size() != nPrevNodeCount)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nPrevNodeCount = vNodes.size();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MainFrameRepaint();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Find which sockets have data to receive<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; struct timeval timeout;<br />&nbsp; &nbsp; &nbsp; &nbsp; timeout.tv_sec&nbsp; = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; timeout.tv_usec = 50000; // frequency to poll pnode-&gt;vSend<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; struct fd_set fdsetRecv;<br />&nbsp; &nbsp; &nbsp; &nbsp; struct fd_set fdsetSend;<br />&nbsp; &nbsp; &nbsp; &nbsp; FD_ZERO(&amp;fdsetRecv);<br />&nbsp; &nbsp; &nbsp; &nbsp; FD_ZERO(&amp;fdsetSend);<br />&nbsp; &nbsp; &nbsp; &nbsp; SOCKET hSocketMax = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; FD_SET(hListenSocket, &amp;fdsetRecv);<br />&nbsp; &nbsp; &nbsp; &nbsp; hSocketMax = max(hSocketMax, hListenSocket);<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FD_SET(pnode-&gt;hSocket, &amp;fdsetRecv);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hSocketMax = max(hSocketMax, pnode-&gt;hSocket);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_vSend)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pnode-&gt;vSend.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FD_SET(pnode-&gt;hSocket, &amp;fdsetSend);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[0] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; int nSelect = select(hSocketMax + 1, &amp;fdsetRecv, &amp;fdsetSend, NULL, &amp;timeout);<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[0] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(0);<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nSelect == SOCKET_ERROR)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nErr = WSAGetLastError();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;select failed: %d\n&quot;, nErr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt;= hSocketMax; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FD_SET(i, &amp;fdsetRecv);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FD_SET(i, &amp;fdsetSend);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sleep(timeout.tv_usec/1000);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; LARGE_INTEGER PerformanceCount;<br />&nbsp; &nbsp; &nbsp; &nbsp; QueryPerformanceCounter(&amp;PerformanceCount);<br />&nbsp; &nbsp; &nbsp; &nbsp; RAND_add(&amp;PerformanceCount.LowPart, sizeof(PerformanceCount.LowPart), 1.0);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //// debug<br />&nbsp; &nbsp; &nbsp; &nbsp; //foreach(CNode* pnode, vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; //{<br />&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; printf(&quot;vRecv = %-5d &quot;, pnode-&gt;vRecv.size());<br />&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp; &nbsp; printf(&quot;vSend = %-5d&nbsp; &nbsp; &quot;, pnode-&gt;vSend.size());<br />&nbsp; &nbsp; &nbsp; &nbsp; //}<br />&nbsp; &nbsp; &nbsp; &nbsp; //printf(&quot;\n&quot;);<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Accept new connections<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; if (FD_ISSET(hListenSocket, &amp;fdsetRecv))<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct sockaddr_in sockaddr;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int len = sizeof(sockaddr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&amp;sockaddr, &amp;len);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAddress addr(sockaddr.sin_addr.s_addr, sockaddr.sin_port);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hSocket == INVALID_SOCKET)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (WSAGetLastError() != WSAEWOULDBLOCK)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;ERROR ThreadSocketHandler accept failed: %d\n&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s accepted connection from %s\n&quot;, addrLocalHost.ToString().c_str(), addr.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CNode* pnode = new CNode(hSocket, addr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;fInbound = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodes.push_back(pnode);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; // Service each socket<br />&nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CNode*&gt; vNodesCopy;<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodesCopy = vNodes;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodesCopy)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SOCKET hSocket = pnode-&gt;hSocket;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Receive<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (FD_ISSET(hSocket, &amp;fdsetRecv))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_vRecv)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream&amp; vRecv = pnode-&gt;vRecv;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nPos = vRecv.size();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // typical socket buffer is 8K-64K<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const unsigned int nBufSize = 0x10000;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vRecv.resize(nPos + nBufSize);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nBytes = recv(hSocket, &amp;vRecv[nPos], nBufSize, 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vRecv.resize(nPos + max(nBytes, 0));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nBytes == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // socket closed gracefully<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pnode-&gt;fDisconnect)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;recv: socket closed\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;fDisconnect = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (nBytes &lt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // socket error<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nErr = WSAGetLastError();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nErr != WSAEWOULDBLOCK &amp;&amp; nErr != WSAEMSGSIZE &amp;&amp; nErr != WSAEINTR &amp;&amp; nErr != WSAEINPROGRESS)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pnode-&gt;fDisconnect)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;recv failed: %d\n&quot;, nErr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;fDisconnect = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Send<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (FD_ISSET(hSocket, &amp;fdsetSend))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_vSend)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDataStream&amp; vSend = pnode-&gt;vSend;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!vSend.empty())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nBytes = send(hSocket, &amp;vSend[0], vSend.size(), 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nBytes &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vSend.erase(vSend.begin(), vSend.begin() + nBytes);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (nBytes == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;ReadyToDisconnect())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;vSend.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;send error %d\n&quot;, nBytes);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnode-&gt;ReadyToDisconnect())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;vSend.clear();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(10);<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />void ThreadOpenConnections(void* parg)<br />{<br />&nbsp; &nbsp; IMPLEMENT_RANDOMIZE_STACK(ThreadOpenConnections(parg));<br /><br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[1] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(1);<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThreadOpenConnections2(parg);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; CATCH_PRINT_EXCEPTION(&quot;ThreadOpenConnections()&quot;)<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[1] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(5000);<br />&nbsp; &nbsp; }<br />}<br /><br />void ThreadOpenConnections2(void* parg)<br />{<br />&nbsp; &nbsp; printf(&quot;ThreadOpenConnections started\n&quot;);<br />&nbsp; &nbsp; unsigned int nTries = 0;<br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; //// number of connections may still need to be increased before release<br />&nbsp; &nbsp; &nbsp; &nbsp; // Initiate network connections<br />&nbsp; &nbsp; &nbsp; &nbsp; if (vNodes.size() &lt; 5 &amp;&amp; vNodes.size() &lt; mapAddresses.size())<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Make a list of unique class C&#039;s<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned char pchIPCMask[4] = { 0xff, 0xff, 0xff, 0x00 };<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nIPCMask = *(unsigned int*)pchIPCMask;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;unsigned int&gt; vIPC;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapAddresses)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vIPC.reserve(mapAddresses.size());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int nPrev = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const PAIRTYPE(vector&lt;unsigned char&gt;, CAddress)&amp; item, mapAddresses)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const CAddress&amp; addr = item.second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!addr.IsIPv4())<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Taking advantage of mapAddresses being in sorted order,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // with IPs of the same class C grouped together.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int ipC = addr.ip &amp; nIPCMask;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ipC != nPrev)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vIPC.push_back(nPrev = ipC);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The IP selection process is designed to limit vulnerability to address flooding.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Any class C (a.b.c.?) has an equal chance of being chosen, then an IP is<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // chosen within the class C.&nbsp; An attacker may be able to allocate many IPs, but<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // they would normally be concentrated in blocks of class C&#039;s.&nbsp; They can hog the<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // attention within their class C, but not the whole IP address space overall.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // A lone node in a class C will get as much attention as someone holding all 255<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // IPs in another class C.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool fSuccess = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nLimit = vIPC.size();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (!fSuccess &amp;&amp; nLimit-- &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Choose a random class C<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64 nRand;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RAND_bytes((unsigned char*)&amp;nRand, sizeof(nRand));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsigned int ipC = vIPC[nRand % vIPC.size()];<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Organize all addresses in the class C by IP<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;unsigned int, vector&lt;CAddress&gt; &gt; mapIP;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_mapAddresses)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (map&lt;vector&lt;unsigned char&gt;, CAddress&gt;::iterator mi = mapAddresses.lower_bound(CAddress(ipC, 0).GetKey());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mi != mapAddresses.upper_bound(CAddress(ipC | ~nIPCMask, 0xffff).GetKey());<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++mi)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const CAddress&amp; addr = (*mi).second;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapIP[addr.ip].push_back(addr);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Choose a random IP in the class C<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RAND_bytes((unsigned char*)&amp;nRand, sizeof(nRand));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map&lt;unsigned int, vector&lt;CAddress&gt; &gt;::iterator mi = mapIP.begin();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; advance(mi, nRand % mapIP.size());<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Once we&#039;ve chosen an IP, we&#039;ll try every given port before moving on<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(const CAddress&amp; addrConnect, (*mi).second)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (addrConnect.ip == addrLocalHost.ip || !addrConnect.IsIPv4() || FindNode(addrConnect.ip))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CNode* pnode = ConnectNode(addrConnect);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pnode)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;fNetworkNode = true;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Advertise our address<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CAddress&gt; vAddrToSend;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vAddrToSend.push_back(addrLocalHost);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;PushMessage(&quot;addr&quot;, vAddrToSend);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Get as many addresses as we can<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;PushMessage(&quot;getaddr&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ////// should the one on the receiving end do this too?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Subscribe our local subscription list<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const unsigned int nHops = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (unsigned int nChannel = 0; nChannel &lt; pnodeLocalHost-&gt;vfSubscribe.size(); nChannel++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pnodeLocalHost-&gt;vfSubscribe[nChannel])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;PushMessage(&quot;subscribe&quot;, nChannel, nHops);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fSuccess = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nTries++;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Wait<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[1] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(100 + nTries * 5);<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[1] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(1);<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br />void ThreadMessageHandler(void* parg)<br />{<br />&nbsp; &nbsp; IMPLEMENT_RANDOMIZE_STACK(ThreadMessageHandler(parg));<br /><br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[2] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(2);<br />&nbsp; &nbsp; &nbsp; &nbsp; try<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThreadMessageHandler2(parg);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; CATCH_PRINT_EXCEPTION(&quot;ThreadMessageHandler()&quot;)<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[2] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(5000);<br />&nbsp; &nbsp; }<br />}<br /><br />void ThreadMessageHandler2(void* parg)<br />{<br />&nbsp; &nbsp; printf(&quot;ThreadMessageHandler started\n&quot;);<br />&nbsp; &nbsp; loop<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; // Poll the connected nodes for messages<br />&nbsp; &nbsp; &nbsp; &nbsp; vector&lt;CNode*&gt; vNodesCopy;<br />&nbsp; &nbsp; &nbsp; &nbsp; CRITICAL_BLOCK(cs_vNodes)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vNodesCopy = vNodes;<br />&nbsp; &nbsp; &nbsp; &nbsp; foreach(CNode* pnode, vNodesCopy)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;AddRef();<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Receive messages<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_vRecv)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessMessages(pnode);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Send messages<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRY_CRITICAL_BLOCK(pnode-&gt;cs_vSend)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SendMessages(pnode);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pnode-&gt;Release();<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; // Wait and allow messages to bunch up<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[2] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(200);<br />&nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[2] = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; CheckForShutdown(2);<br />&nbsp; &nbsp; }<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />//// todo: start one thread per processor, use getenv(&quot;NUMBER_OF_PROCESSORS&quot;)<br />void ThreadBitcoinMiner(void* parg)<br />{<br />&nbsp; &nbsp; vfThreadRunning[3] = true;<br />&nbsp; &nbsp; CheckForShutdown(3);<br />&nbsp; &nbsp; try<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; bool fRet = BitcoinMiner();<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;BitcoinMiner returned %s\n\n\n&quot;, fRet ? &quot;true&quot; : &quot;false&quot;);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; CATCH_PRINT_EXCEPTION(&quot;BitcoinMiner()&quot;)<br />&nbsp; &nbsp; vfThreadRunning[3] = false;<br />}<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />bool StartNode(string&amp; strError)<br />{<br />&nbsp; &nbsp; strError = &quot;&quot;;<br /><br /><br />&nbsp; &nbsp; // Sockets startup<br />&nbsp; &nbsp; WSADATA wsadata;<br />&nbsp; &nbsp; int ret = WSAStartup(MAKEWORD(2,2), &amp;wsadata);<br />&nbsp; &nbsp; if (ret != NO_ERROR)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: TCP/IP socket library failed to start (WSAStartup returned error %d)&quot;, ret);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Get local host ip<br />&nbsp; &nbsp; char pszHostName[255];<br />&nbsp; &nbsp; if (gethostname(pszHostName, 255) == SOCKET_ERROR)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Unable to get IP address of this computer (gethostname returned error %d)&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; struct hostent* pHostEnt = gethostbyname(pszHostName);<br />&nbsp; &nbsp; if (!pHostEnt)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Unable to get IP address of this computer (gethostbyname returned error %d)&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; addrLocalHost = CAddress(*(long*)(pHostEnt-&gt;h_addr_list[0]),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DEFAULT_PORT,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nLocalServices);<br />&nbsp; &nbsp; printf(&quot;addrLocalHost = %s\n&quot;, addrLocalHost.ToString().c_str());<br /><br />&nbsp; &nbsp; // Create socket for listening for incoming connections<br />&nbsp; &nbsp; SOCKET hListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br />&nbsp; &nbsp; if (hListenSocket == INVALID_SOCKET)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Couldn&#039;t open socket for incoming connections (socket returned error %d)&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // Set to nonblocking, incomming connections will also inherit this<br />&nbsp; &nbsp; u_long nOne = 1;<br />&nbsp; &nbsp; if (ioctlsocket(hListenSocket, FIONBIO, &amp;nOne) == SOCKET_ERROR)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Couldn&#039;t set properties on socket for incoming connections (ioctlsocket returned error %d)&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // The sockaddr_in structure specifies the address family,<br />&nbsp; &nbsp; // IP address, and port for the socket that is being bound<br />&nbsp; &nbsp; int nRetryLimit = 15;<br />&nbsp; &nbsp; struct sockaddr_in sockaddr;<br />&nbsp; &nbsp; sockaddr.sin_family = AF_INET;<br />&nbsp; &nbsp; sockaddr.sin_addr.s_addr = addrLocalHost.ip;<br />&nbsp; &nbsp; sockaddr.sin_port = addrLocalHost.port;<br />&nbsp; &nbsp; if (bind(hListenSocket, (struct sockaddr*)&amp;sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; int nErr = WSAGetLastError();<br />&nbsp; &nbsp; &nbsp; &nbsp; if (nErr == WSAEADDRINUSE)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Unable to bind to port %s on this computer. The program is probably already running.&quot;, addrLocalHost.ToString().c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Unable to bind to port %s on this computer (bind returned error %d)&quot;, addrLocalHost.ToString().c_str(), nErr);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; printf(&quot;bound to addrLocalHost = %s\n\n&quot;, addrLocalHost.ToString().c_str());<br /><br />&nbsp; &nbsp; // Listen for incoming connections<br />&nbsp; &nbsp; if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = strprintf(&quot;Error: Listening for incoming connections failed (listen returned error %d)&quot;, WSAGetLastError());<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br /><br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; // Start threads<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; if (_beginthread(ThreadSocketHandler, 0, new SOCKET(hListenSocket)) == -1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = &quot;Error: _beginthread(ThreadSocketHandler) failed&quot;;<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (_beginthread(ThreadOpenConnections, 0, NULL) == -1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = &quot;Error: _beginthread(ThreadOpenConnections) failed&quot;;<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (_beginthread(ThreadMessageHandler, 0, NULL) == -1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; strError = &quot;Error: _beginthread(ThreadMessageHandler) failed&quot;;<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%s\n&quot;, strError.c_str());<br />&nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return true;<br />}<br /><br />bool StopNode()<br />{<br />&nbsp; &nbsp; printf(&quot;StopNode()\n&quot;);<br />&nbsp; &nbsp; fShutdown = true;<br />&nbsp; &nbsp; nTransactionsUpdated++;<br />&nbsp; &nbsp; while (count(vfThreadRunning.begin(), vfThreadRunning.end(), true))<br />&nbsp; &nbsp; &nbsp; &nbsp; Sleep(10);<br />&nbsp; &nbsp; Sleep(50);<br /><br />&nbsp; &nbsp; // Sockets shutdown<br />&nbsp; &nbsp; WSACleanup();<br />&nbsp; &nbsp; return true;<br />}<br /><br />void CheckForShutdown(int n)<br />{<br />&nbsp; &nbsp; if (fShutdown)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; if (n != -1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vfThreadRunning[n] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; _endthread();<br />&nbsp; &nbsp; }<br />}<br /></div>[/pre]</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:37:33 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><br />I just thought I should put these someplace where the community would have access to them.&nbsp; It&#039;s a little window on history. <br /><br />One interesting note is that the genesis block in this code has a different hash.&nbsp; <br /><br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>December 23, 2013, 07:38:48 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Interesting.<br /><br />What was the context of you getting them from Satoshi? (I assume)<br /><br />edit: might be helpful to have the exact files rather than a cut-n-paste to get an &quot;official&quot; copy. Feel free to email them to me, I can put them up somewhere for you: pete@petertodd.org</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:41:29 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I was on the Metzdowd cryptography list at that time. <br /><br />Satoshi posted asking for professional crypto geeks to review his project. <br /><br />Hal Finney and I were two of those who answered, and he sent the archive to several of us. <br /><br />Hal probably has this same archive in his mail as well, if he saved it. </div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>December 23, 2013, 07:47:18 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Cool!<br /><br />Something that I immediately noticed was how the scriptPubKey&#039;s all start with OP_CODESEPARATOR; for me that&#039;s fascinating to see as I commented (https://bitcointalk.org/index.php?topic=255145.msg2773654#msg2773654) a few months ago on how it would have allowed signing authority on a transaction to be delegated.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>December 23, 2013, 07:47:45 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Is that all the source you have? No script.cpp?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 07:55:25 PM</b>
					<hr />
					<div style="margin: 0 5ex;">That is the whole source. &nbsp;There was no script.cpp at that time. &nbsp;<br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>deepceleron</b> on <b>December 23, 2013, 08:00:46 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader">Quote from: <a class="ul" href="http://www.metzdowd.com/pipermail/cryptography/2008-November/014863.html">http://www.metzdowd.com/pipermail/cryptography/2008-November/014863.html</a></div><div class="quote"><br />Satoshi Nakamoto satoshi at vistomail.com<br /><b>Mon Nov 17 12:24:43 EST 2008</b><br /><br />&nbsp;&nbsp; &nbsp;Previous message: Bitcoin P2P e-cash paper<br />&nbsp;&nbsp; &nbsp;Next message: Bitcoin P2P e-cash paper<br />&nbsp;&nbsp; &nbsp;Messages sorted by: [ date ] [ thread ] [ subject ] [ author ]<br /><br /><i>...(SNIP)...</i><br /><br />I believe I&#039;ve worked through all those little details over the<br />last year and a half while coding it, and there were a lot of them.<br />The functional details are not covered in the paper, but the<br />sourcecode is coming soon. &nbsp;<b>I sent you the main files.<br />(available by request at the moment, full release soon)</b><br /><br />Satoshi Nakamoto</div></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>December 23, 2013, 08:07:38 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Also interesting is how there&#039;s a &quot;getmywtxes&quot; command in ProcessMessage, which looks like it&#039;s designed to get a thin-client&#039;s wallet transactions for them. Seems to be that it retrieves all transactions related to the specified scriptPubKey hashes in a specific block.<br /><br />There&#039;s also a &quot;wtx&quot; command which seems to add a CWalletTx to the node&#039;s local wallet! Bizzare - quite possibly just some code for testing.<br /><br />Accept block is fascinating, just look at the commend &quot;Add atoms to user reviews for coins created&quot; (?!)<br /><br /><br /><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4109079#msg4109079">Quote from: Cryddit on December 23, 2013, 07:55:25 PM</a></div><div class="quote">That is the whole source. &nbsp;There was no script.cpp at that time. &nbsp;<br /></div><br />You mean this is all he sent you; the source is obviously missing functions that are called and wouldn&#039;t have compiled. Pity, fascinating to see Bitcoin in this intermediate stage of development.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 08:13:32 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4109269#msg4109269">Quote from: Peter Todd on December 23, 2013, 08:07:38 PM</a></div><div class="quote"><br /><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4109079#msg4109079">Quote from: Cryddit on December 23, 2013, 07:55:25 PM</a></div><div class="quote">That is the whole source. &nbsp;There was no script.cpp at that time. &nbsp;<br /></div><br />You mean this is all he sent you; the source is obviously missing functions that are called and wouldn&#039;t have compiled. Pity, fascinating to see Bitcoin in this intermediate stage of development.<br /></div><br />You&#039;re right about that;&nbsp; The source itself refers to several header files that weren&#039;t in the source archive I received.&nbsp; This is the stuff, I guess, that Satoshi felt that he needed pros to review.&nbsp; <br /><br /><br /><br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Mike Hearn</b> on <b>December 23, 2013, 08:30:45 PM</b>
					<hr />
					<div style="margin: 0 5ex;">OP_CODESEPARATOR was in the first released version too. It was part of his broken method of running scripts via concatenation.<br /><br />User reviews is because he originally intended Bitcoin to have an integrated P2P eBay style market. The idea was that user ratings/reviews would be weighted by how much mining you had done. It was never finished and eventually the code to support it was taken out - he realised the JSON-RPC API was more important.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>December 23, 2013, 08:39:54 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4109606#msg4109606">Quote from: Mike Hearn on December 23, 2013, 08:30:45 PM</a></div><div class="quote">OP_CODESEPARATOR was in the first released version too. It was part of his broken method of running scripts via concatenation.<br /></div><br />In the Bitcoin v0.1 release OP_CODESEPARATOR was always inserted between the scriptSig and scriptPubKey prior to calling EvalScript() This pre-release sourcecode implies that was not automatically done, which allows for scripts to take advantage of that after the fact to delegate signing authority after the fact. (though to fully take advantage of the idea you need the notion of a OP_CODESEPARATOR &quot;stack&quot;)<br /><br />The idea is &quot;broken&quot; only in that OP_RETURN originally could cause a script to return valid prematurely; now that OP_RETURN only fails a script prematurely an explicit OP_CODESEPARATOR design would work fine.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>deepceleron</b> on <b>December 23, 2013, 08:52:32 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Cryddit forwarded the email and original file attached:<br /><div class="quoteheader">Quote from: satoshi</div><div class="quote">&gt; Rather than you guys trying to guess and fill in the blanks <br />&gt; and reinvent the wheel, here&#039;s the core source files attached <br />&gt; (bitcoin_src1.rar) so you can see how I&#039;m implementing it. <br /><br />&gt; main.h and main.cpp are the bitcoin system<br />&gt; node.h and node.cpp are the peer network communications infrastructure<br /><br />&gt; Satoshi</div>http://we.lovebitco.in/bitcoin_src1.rar<br /><br /><br /><br />This looks like a fun place to post some more history:<br /><br />http://sourceforge.net/users/nakamoto2 - Joined: 2008-10-05<br /><br />Thanks to robots.txt, there&#039;s no source code to recover off sourceforge through the Internet Archive, but here&#039;s a screenshot from Jan 3 2009 (same date as genesis), with an unreleased blockchain at block 213 and three other connections.<br /><br /><a href="http://we.lovebitco.in/img/bitcoinss-Jan-03-2009.jpg">http://we.lovebitco.in/img/bitcoinss-Jan-03-2009.jpg</a></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Valle</b> on <b>December 23, 2013, 09:45:09 PM</b>
					<hr />
					<div style="margin: 0 5ex;">That&#039;s very strange. Have a look: https://blockchain.info/address/19CncWdnU57yq4QHBNVPdScFB54JkPGu28</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>michagogo</b> on <b>December 23, 2013, 09:49:33 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4110589#msg4110589">Quote from: Valle on December 23, 2013, 09:45:09 PM</a></div><div class="quote">That&#039;s very strange. Have a look: https://blockchain.info/address/19CncWdnU57yq4QHBNVPdScFB54JkPGu28<br /></div>What&#039;s strange about that? It&#039;s simple: that address hadn&#039;t been used, until someone sent a thousand satoshis to it a few months ago.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>marcus_of_augustus</b> on <b>December 23, 2013, 09:51:43 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Ok, this is interesting.<br /><br />So can we get the actual files posted somewhere?<br /><br />Edit: ooops just saw that been posted ...</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>deepceleron</b> on <b>December 23, 2013, 09:53:03 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4110665#msg4110665">Quote from: marcus_of_augustus on December 23, 2013, 09:51:43 PM</a></div><div class="quote">Ok, this is interesting.<br /><br />So can we get the actual files posted somewhere?<br /></div>Three posts back?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 23, 2013, 10:39:15 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4110643#msg4110643">Quote from: michagogo on December 23, 2013, 09:49:33 PM</a></div><div class="quote"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4110589#msg4110589">Quote from: Valle on December 23, 2013, 09:45:09 PM</a></div><div class="quote">That&#039;s very strange. Have a look: https://blockchain.info/address/19CncWdnU57yq4QHBNVPdScFB54JkPGu28<br /></div>What&#039;s strange about that? It&#039;s simple: that address hadn&#039;t been used, until someone sent a thousand satoshis to it a few months ago.<br /></div><br />Yeah, someone&#039;s been sending &#039;dust&#039; to old addresses all along the blockchain.&nbsp; If I understand it correctly, it&#039;s an attempt to link the owners of those accounts to purchases being made today.&nbsp; <br /><br />The automatic coin selection in the client picks up the extra txOut and may spend it along with other txOuts next time you buy some alpaca socks.&nbsp; &nbsp;And then somebody somewhere knows that the same person who owns that older txout is the person who bought those alpaca socks. <br /><br />This is when they can&#039;t figure it out just by looking at the transaction history, of course.&nbsp; But that little bit of dust is someone trying to figure out who owns the account. <br /><br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Sergio_Demian_Lerner</b> on <b>December 23, 2013, 11:44:15 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I also have these files, sent to me by one of the early reviewers of the code.<br />Another interesting fact (I talked in laBitConf) is the fact that there was already a genesis block in it, which was obviously discarded after testing was done.<br /><br />Still other interesting facts are these comments in main.h<br /><br />&nbsp;///static const unsigned int MINPROOFOFWORK = 40; /// need to decide the right difficulty to start with<br />static const unsigned int MINPROOFOFWORK = 20; &nbsp;/// ridiculously easy for testing<br /><br /><br />So Satoshi may had the capability of 2^40 hashes per 10 minute interval (but he finally fixed it at 32).<br /><br />These were the latest changes during that period:<br />&nbsp;<br />* Two more decimal digits for BTC denomination<br />* Added nSequence to TxOut<br />* Added nVersion to Block<br />* Changed nBits from zero bit count to compact target format.<br /><br />Regards, Sergio.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>jdbtracker</b> on <b>December 25, 2013, 07:33:00 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Wow, thank you so much, it is mind blowing to see this, I&#039;m reading all the code now.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Altoidnerd</b> on <b>December 28, 2013, 10:07:06 AM</b>
					<hr />
					<div style="margin: 0 5ex;">Got a decent question who the hell is S.N. Have we figured that one out yet?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>December 28, 2013, 04:21:14 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4183050#msg4183050">Quote from: Altoidnerd on December 28, 2013, 10:07:06 AM</a></div><div class="quote">Got a decent question who the hell is S.N. Have we figured that one out yet?<br /></div><br />I may have figured it out.&nbsp; At least I know someone who had the motivation, skills, and time to have made it, had no need for all the money Satoshi hasn&#039;t spent, and who also had a good reason to withdraw from the community when Satoshi did.&nbsp; But there&#039;s no proof, and I&#039;m not motivated to share my speculations. <br /><br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>December 28, 2013, 04:32:08 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4187769#msg4187769">Quote from: Cryddit on December 28, 2013, 04:21:14 PM</a></div><div class="quote">I may have figured it out.&nbsp; At least I know someone who had the motivation, skills, and time to have made it, had no need for all the money Satoshi hasn&#039;t spent, and who also had a good reason to withdraw from the community when Satoshi did.&nbsp; But there&#039;s no proof, and I&#039;m not motivated to share my speculations. <br /></div><br />Here&#039;s a fun game we can play: could you use something like virtual-notary.org or proofofexistence.com to upload a hash of a (properly padded) string containing the name of the individual? If the name ever leaks out, we can see if your guess was correct.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Altoidnerd</b> on <b>December 28, 2013, 07:36:37 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4187911#msg4187911">Quote from: mmeijeri on December 28, 2013, 04:32:08 PM</a></div><div class="quote"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4187769#msg4187769">Quote from: Cryddit on December 28, 2013, 04:21:14 PM</a></div><div class="quote">I may have figured it out.&nbsp; At least I know someone who had the motivation, skills, and time to have made it, had no need for all the money Satoshi hasn&#039;t spent, and who also had a good reason to withdraw from the community when Satoshi did.&nbsp; But there&#039;s no proof, and I&#039;m not motivated to share my speculations. <br /></div><br />Here&#039;s a fun game we can play: could you use something like virtual-notary.org or proofofexistence.com to upload a hash of a (properly padded) string containing the name of the individual? If the name ever leaks out, we can see if your guess was correct.<br /></div><br />Extremely nerdy, very cool idea.&nbsp; </div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Voodah</b> on <b>December 28, 2013, 11:50:17 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Nice find. Thanks for this.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>January 22, 2014, 11:07:36 AM</b>
					<hr />
					<div style="margin: 0 5ex;">A pity that script, VerifySignature and SignSignature aren&#039;t included. It might have shed some light on why OP_CHECKSIG works the way it does.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>jl2012</b> on <b>January 22, 2014, 01:40:24 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4108815#msg4108815">Quote from: Cryddit on December 23, 2013, 07:37:33 PM</a></div><div class="quote"><br />One interesting note is that the genesis block in this code has a different hash.&nbsp; <br /><br /></div><br />Isn&#039;t this expected? Unless Satoshi was a prophet, he shouldn&#039;t know &quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&quot; in November 2008</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Mike Hearn</b> on <b>January 22, 2014, 03:02:33 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I strongly suspect that in November 2008 there was no script. It always felt like a last minute addition to me. It&#039;s not mentioned in the white paper at all and everything we know about it was reverse engineered out of the source. And as noted the design is a bit screwy - CHECKSIG feels like something that was refactored out of a pre-existing code base rather than something you&#039;d actually sit down and design on paper.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>January 22, 2014, 03:11:14 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4665627#msg4665627">Quote from: Mike Hearn on January 22, 2014, 03:02:33 PM</a></div><div class="quote">I strongly suspect that in November 2008 there was no script. It always felt like a last minute addition to me. It&#039;s not mentioned in the white paper at all and everything we know about it was reverse engineered out of the source. And as noted the design is a bit screwy - CHECKSIG feels like something that was refactored out of a pre-existing code base rather than something you&#039;d actually sit down and design on paper.<br /></div><br />I think there was, because the fields are already named scriptPubKey and scriptSig. It was probably preceded by an implementation that had no scripts, just public keys and signatures. I wonder if there was an intermediate phase that allowed multiple keys per output, but not yet full scripts. Maybe the concatenation business made sense in such a context.<br /><br />Also note that SignSignature and VerifySignature aren&#039;t in the files here, although that would be the obvious place to put them. I suspect they used to be there in an even earlier version and were moved to script after that was split off. And script may have been too immature for Satoshi to share just yet. Then again, it&#039;s interesting to see that it does already include nLockTime and transaction replacement.<br /><br />I&#039;ve also wondered if maybe there was an earlier implementation that used balances, not outputs, as that is what I would have started with. The most obvious starting point might be single input, single output, single signature transactions between accounts. But there is no evidence of this, and maybe previous ideas discussed in the literature already chained individual coins.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>January 22, 2014, 03:16:58 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I wonder what a Forth expert would make of Satoshi&#039;s choice of opcodes. Did he lift it from somewhere, does it look like the work of an experienced Forth hacker? My only experience with Forth is playing around with PostScript a bit, so I can&#039;t tell.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>marcus_of_augustus</b> on <b>January 22, 2014, 07:21:52 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4665920#msg4665920">Quote from: mmeijeri on January 22, 2014, 03:16:58 PM</a></div><div class="quote">I wonder what a Forth expert would make of Satoshi&#039;s choice of opcodes. Did he lift it from somewhere, does it look like the work of an experienced Forth hacker? My only experience with Forth is playing around with PostScript a bit, so I can&#039;t tell.<br /></div><br />... rich vein this one, imo.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>jdbtracker</b> on <b>January 25, 2014, 08:19:08 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Wow this is messed up, the whole thing is unsigned integers; it&#039;s all addition. It&#039;s an interesting design choice, not just prevents charge-backs but simplifies a lot of the math, you can remove some of <br />the steps but at the cost of understandability.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>scintill</b> on <b>February 03, 2014, 03:40:19 AM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4665627#msg4665627">Quote from: Mike Hearn on January 22, 2014, 03:02:33 PM</a></div><div class="quote">And as noted the design is a bit screwy - CHECKSIG feels like something that was refactored out of a pre-existing code base rather than something you&#039;d actually sit down and design on paper.<br /></div><br />Yeah, a more apt name would be OP_DO_BITCOIN or something, since it rolls so much core functionality into one inflexible &quot;opcode.&quot;&nbsp; The rest of Script seems like pointless toys, since not even the most trivial inspections of the transaction or blockchain is possible.&nbsp; It is cool to see the hash collision bounties that have been published using some of the other Script opcodes.&nbsp; (I&#039;d be interested to see other novel uses, too. Maybe smarter people have found that Script is not as useless as I think.)</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>February 03, 2014, 08:04:12 AM</b>
					<hr />
					<div style="margin: 0 5ex;">I agree with you that script would be drastically more useful if a script could examine the blockchain, look for another tx, etc. <br /><br />But there are logistic issues.&nbsp; <br /><br />It&#039;s already the case that spends using outputs from other transactions not yet at least (confirmation depth) in the blockchain are assigned low priority.&nbsp; <br /><br />But in a universe where a spend of those outputs caused a script with the ability to examine the blockchain to run, I&#039;d want the script to only be able to examine the blockchain up to (mining output confirmation depth) *prior* to the spend.&nbsp; Which could be long after the transaction containing the script was made, but could not be very soon before the transaction *spending* that output was made.&nbsp; In any case it would need to be considerably longer than the current &quot;confirmation&quot; time, and spends should outright fail rather than just have low priority.&nbsp; This is because a script may reveal information pertinent to the continuing blockchain. If it does so in an orphaned block, then that information is revealed when it ought not have been. We don&#039;t want information pertinent to the blockchain that&#039;s not getting orphaned revealed based on a view of history that might possibly still get orphaned.&nbsp; Also, the same restriction is necessary because it should not be possible for a valid spend (where the txin scripts return true) to later become invalid based on additional information getting added to the blockchain. <br /><br />Finally, it makes checking transactions more expensive, and checking tx would require accessing the blockchain out of sequence.<br /><br />All these difficulties can be overcome of course, I&#039;m just saying the design criteria are actually pretty finicky. </div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>scintill</b> on <b>February 03, 2014, 09:54:18 AM</b>
					<hr />
					<div style="margin: 0 5ex;">Yeah, I figured there are hairy problems about scripts depending on arbitrary other transactions.&nbsp; Maybe Satoshi gave up on making script really work because he didn&#039;t know if he could do it right.&nbsp; Best to get a solid foundation first.<br /><br />Just having more information about the transaction itself and a bit of global state could be useful.&nbsp; E.g., maybe locktime could be implemented in script, if the script could know the time.&nbsp; A script could check that its inputs are evenly distributed N ways across its outputs, for fair splitting of funds between partners or something.&nbsp; I guess multisig and other collaborative tx signing allows the key holders to mediate these kinds of things themselves.<br /><br />I have thought about scripts being able to &quot;call&quot; prior transactions&#039; scripts, to recycle useful but complex behavior, if the reference and some optional &quot;patching&quot; is shorter than duplicating the script itself.&nbsp; But as you say, this kind of thing would be a nightmare of inefficiency and DoS attack surface even at merely today&#039;s blockchain size. :)</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>February 03, 2014, 10:31:15 AM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4908723#msg4908723">Quote from: scintill on February 03, 2014, 09:54:18 AM</a></div><div class="quote">Yeah, I figured there are hairy problems about scripts depending on arbitrary other transactions.&nbsp; Maybe Satoshi gave up on making script really work because he didn&#039;t know if he could do it right.&nbsp; Best to get a solid foundation first.<br /></div><br />Heck, having <i>transactions</i> depend on other transactions in a block is a potential scalability problem because it makes it non-trivial to process blocks and update the UTXO set in parallel, especially in a lossely coupled manner. (ie multiple co-operating nodes)</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>zulu860</b> on <b>February 03, 2014, 11:52:21 AM</b>
					<hr />
					<div style="margin: 0 5ex;">Wow thank you for posting this was fun to read&nbsp; ;D</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>February 03, 2014, 01:24:33 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4736353#msg4736353">Quote from: jdbtracker on January 25, 2014, 08:19:08 PM</a></div><div class="quote">Wow this is messed up, the whole thing is unsigned integers; it&#039;s all addition.<br /></div><br />Double entry accounting is all unsigned integers and addition too. :-)</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>February 03, 2014, 01:28:04 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I agree with your general point, but this jumped out:<br /><br /><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4907490#msg4907490">Quote from: Cryddit on February 03, 2014, 08:04:12 AM</a></div><div class="quote">This is because a script may reveal information pertinent to the continuing blockchain. If it does so in an orphaned block, then that information is revealed when it ought not have been.<br /></div><br />What are you thinking of that a (spending) script could reveal? A hash preimage?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>February 03, 2014, 01:30:32 PM</b>
					<hr />
					<div style="margin: 0 5ex;">It would be nice if scripts had access to just the information in the transaction itself and that does not need access to block height or any other data from the rest of the blockchain. Things like number and amounts of the inputs, output scripts etc.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Cryddit</b> on <b>February 03, 2014, 06:08:12 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4911230#msg4911230">Quote from: mmeijeri on February 03, 2014, 01:28:04 PM</a></div><div class="quote"><br /><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg4907490#msg4907490">Quote from: Cryddit on February 03, 2014, 08:04:12 AM</a></div><div class="quote">This is because a script (in an orphaned block) may reveal information pertinent to the continuing blockchain. <br /></div>What are you thinking of that a (spending) script could reveal? A hash preimage?<br /></div><br />In principle, a script could reveal anything that was known to the spender prior to the transaction where the spend was made, or anything that could be derived from that knowledge and examination of the blockchain. A hash preimage, a key to decrypt some other binary blob, an arbitrary&nbsp; secret encoded to be read by someone else&#039;s private key, a &quot;go&quot; signal for some irreversible real-world operation, etc. <br /><br />It would suck to get a &quot;go&quot; signal from a script, go down to the bank, and prepare to do your part in an escrow agreement by cashing out a bunch of bonds early (at a loss) so you have cash, then come back home and discover that the &quot;go&quot; signal happened in an orphaned chain.&nbsp; On the one hand, poor logistical planning to do your business that way.&nbsp; On the other, there are sometimes reasons to do weird shit like that, and doing weird shit like that would inspire attacks designed to have exactly the false-signal effect described.<br /><br />We think of scripts as returning a single bit.&nbsp; Either the spend succeeds or not.&nbsp; But remember the value that success or failure depends on is a binary blob the size of a key, and everybody checking the blockchain can read it.<br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Joe_Bauers</b> on <b>February 03, 2014, 07:30:58 PM</b>
					<hr />
					<div style="margin: 0 5ex;">Very cool. Maybe this can be tagged and added as a &quot;release&quot; @ https://github.com/bitcoin/bitcoin for archival purposes?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Altoidnerd</b> on <b>February 21, 2014, 07:29:54 AM</b>
					<hr />
					<div style="margin: 0 5ex;">I&#039;ll post these on my blog, for historical reasons.&nbsp; Unless anyone has a problem with it.<br /><br />I will link and source this discussion.<br /><br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>benjyz</b> on <b>February 21, 2014, 04:19:31 PM</b>
					<hr />
					<div style="margin: 0 5ex;">I&#039;ve got the 0.1 version and the nov08 version on github. blogs are not a good CVS.<br /><br />https://github.com/benjyz/bitcoin0.1/tree/master/nov08<br /><br /><br />the main files from the 0.1 source code in 7000 LOC.<br /><br />&nbsp;&nbsp; &nbsp;2660 ./main.cpp<br />&nbsp;&nbsp; &nbsp;1127 ./script.cpp<br />&nbsp;&nbsp; &nbsp;1020 ./net.cpp<br />&nbsp;&nbsp; &nbsp;604 ./db.cpp<br />&nbsp;&nbsp; &nbsp;554 ./sha.cpp<br />&nbsp;&nbsp; &nbsp;373 ./util.cpp<br />&nbsp;&nbsp; &nbsp;265 ./irc.cpp<br />&nbsp;&nbsp; &nbsp;264 ./market.cpp<br />&nbsp;&nbsp; &nbsp;6867 total<br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>itod</b> on <b>February 21, 2014, 04:36:58 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg5283927#msg5283927">Quote from: benjyz on February 21, 2014, 04:19:31 PM</a></div><div class="quote">I&#039;ve got the 0.1 version and the nov08 version on github. blogs are not a good CVS.<br /><br />https://github.com/benjyz/bitcoin0.1/tree/master/nov08<br /><br /><br />the main files from the 0.1 source code in 7000 LOC.<br /><br />&nbsp;&nbsp; &nbsp;2660 ./main.cpp<br />&nbsp;&nbsp; &nbsp;1127 ./script.cpp<br />&nbsp;&nbsp; &nbsp;1020 ./net.cpp<br />&nbsp;&nbsp; &nbsp;604 ./db.cpp<br />&nbsp;&nbsp; &nbsp;554 ./sha.cpp<br />&nbsp;&nbsp; &nbsp;373 ./util.cpp<br />&nbsp;&nbsp; &nbsp;265 ./irc.cpp<br />&nbsp;&nbsp; &nbsp;264 ./market.cpp<br />&nbsp;&nbsp; &nbsp;6867 total<br /></div><br />Original bitcoin software had IRC client included?<br />https://github.com/benjyz/bitcoin0.1/blob/master/irc.cpp (https://github.com/benjyz/bitcoin0.1/blob/master/irc.cpp)<br /><br />What was the idea behind this?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>deepceleron</b> on <b>February 21, 2014, 05:02:07 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg5284225#msg5284225">Quote from: itod on February 21, 2014, 04:36:58 PM</a></div><div class="quote">Original bitcoin software had IRC client included?<br />https://github.com/benjyz/bitcoin0.1/blob/master/irc.cpp (https://github.com/benjyz/bitcoin0.1/blob/master/irc.cpp)<br /><br />What was the idea behind this?<br /></div><br />https://en.bitcoin.it/wiki/Network#IRC</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>itod</b> on <b>February 21, 2014, 05:17:17 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg5284671#msg5284671">Quote from: deepceleron on February 21, 2014, 05:02:07 PM</a></div><div class="quote">https://en.bitcoin.it/wiki/Network#IRC<br /></div><br />Cool, thanks, didn&#039;t knew that.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>benjyz</b> on <b>February 21, 2014, 06:59:17 PM</b>
					<hr />
					<div style="margin: 0 5ex;">IRC is the easiest way to bootstrap messaging. <br /><br />this is a nice overview over the nodes: http://getaddr.bitnodes.io/&nbsp; if the information is correct there are 104729 nodes connected, from 183 countries.<br /><br />see also torrent protocol bootstrap:<br /><br />http://www.bittorrent.org/beps/bep_0005.html</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Joe_Bauers</b> on <b>February 25, 2014, 04:37:11 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg5283927#msg5283927">Quote from: benjyz on February 21, 2014, 04:19:31 PM</a></div><div class="quote">I&#039;ve got the 0.1 version and the nov08 version on github. blogs are not a good CVS.<br /><br />https://github.com/benjyz/bitcoin0.1/tree/master/nov08<br /><br /><br />the main files from the 0.1 source code in 7000 LOC.<br /><br />&nbsp;&nbsp; &nbsp;2660 ./main.cpp<br />&nbsp;&nbsp; &nbsp;1127 ./script.cpp<br />&nbsp;&nbsp; &nbsp;1020 ./net.cpp<br />&nbsp;&nbsp; &nbsp;604 ./db.cpp<br />&nbsp;&nbsp; &nbsp;554 ./sha.cpp<br />&nbsp;&nbsp; &nbsp;373 ./util.cpp<br />&nbsp;&nbsp; &nbsp;265 ./irc.cpp<br />&nbsp;&nbsp; &nbsp;264 ./market.cpp<br />&nbsp;&nbsp; &nbsp;6867 total<br /><br /></div><br />Cool, thanks for doing this. I still think it should also be added to the official repo, but whatever I suppose...&nbsp; ::)</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>February 25, 2014, 05:24:09 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg5283927#msg5283927">Quote from: benjyz on February 21, 2014, 04:19:31 PM</a></div><div class="quote">I&#039;ve got the 0.1 version and the nov08 version on github. blogs are not a good CVS.<br /><br />https://github.com/benjyz/bitcoin0.1/tree/master/nov08<br /><br /><br />the main files from the 0.1 source code in 7000 LOC.<br /><br />&nbsp;&nbsp; &nbsp;2660 ./main.cpp<br />&nbsp;&nbsp; &nbsp;1127 ./script.cpp<br />&nbsp;&nbsp; &nbsp;1020 ./net.cpp<br />&nbsp;&nbsp; &nbsp;604 ./db.cpp<br />&nbsp;&nbsp; &nbsp;554 ./sha.cpp<br />&nbsp;&nbsp; &nbsp;373 ./util.cpp<br />&nbsp;&nbsp; &nbsp;265 ./irc.cpp<br />&nbsp;&nbsp; &nbsp;264 ./market.cpp<br />&nbsp;&nbsp; &nbsp;6867 total<br /><br /></div><br />market.cpp? I don&#039;t see that in your repo - do you actually have a copy of it?</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>benjyz</b> on <b>February 25, 2014, 05:44:24 PM</b>
					<hr />
					<div style="margin: 0 5ex;">yes. I restored the full version with header files in the bitcoin0.1 folder. it looks like a small auction system as Mike said above. it&#039;s only 260 lines.<br /><br />https://github.com/benjyz/bitcoin0.1/blob/master/bitcoin0.1_version/market.cpp<br /><br />so there are 3 versions in the repo (probably should be separate trees):<br /><br />* the root folder only contains the main files for study purposes<br />* the nov08 version<br />* the full 0.1 version with headers and unused parts like the market.cpp</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>mmeijeri</b> on <b>February 25, 2014, 06:52:38 PM</b>
					<hr />
					<div style="margin: 0 5ex;">It would be fun to see what would be needed to get the oldest version to compile and run. You could fill in the blanks with stuff from later versions and then remove what isn&#039;t needed to make it work.</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>Peter Todd</b> on <b>February 25, 2014, 07:20:18 PM</b>
					<hr />
					<div style="margin: 0 5ex;"><div class="quoteheader"><a href="https://bitcointalk.org/index.php?topic=382374.msg5367587#msg5367587">Quote from: benjyz on February 25, 2014, 05:44:24 PM</a></div><div class="quote">yes. I restored the full version with header files in the bitcoin0.1 folder. it looks like a small auction system as Mike said above. it&#039;s only 260 lines.<br /><br />https://github.com/benjyz/bitcoin0.1/blob/master/bitcoin0.1_version/market.cpp<br /><br />so there are 3 versions in the repo (probably should be separate trees):<br /><br />* the root folder only contains the main files for study purposes<br />* the nov08 version<br />* the full 0.1 version with headers and unused parts like the market.cpp<br /></div><br />Awesome thanks!<br /><br />Where exactly did you get this code from? Might be good to add some notes about the source of it in the README. If you have, say, zip files good to put them in the repo for archival purposes. (this <i>is</i> important history after all)</div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>benjyz</b> on <b>February 25, 2014, 09:04:31 PM</b>
					<hr />
					<div style="margin: 0 5ex;">you&#039;re right. I&#039;ve spent a lot of time tracing the history and it is definitely very worth preserving.<br /><br />I have renamed the repo to bitcoinArchive: https://github.com/benjyz/bitcoinArchive<br /><br />I&#039;ve added the 0.1 tar, which originally was from here: https://bitcointalk.org/index.php?topic=68121.0<br /><br />this is the md5sum of the directory, which contains the windows exe and dll:<br />dca1095f053a0c2dc90b19c92bd1ec00 &nbsp;bitcoin-0.1.0.tgz<br /><br />I&#039;ve also added some original posts from the mailing list. If anyone wants to add something...<br /><br />see also:<br />http://p2pfoundation.ning.com/profile/SatoshiNakamoto<br /><br />the bitcoin/github starts with 0.2.6<br /><br /></div>
					<br />
					<hr size="2" width="100%" />
					Title: <b>Re: Bitcoin source from November 2008.</b><br />
					Post by: <b>BitcoinArbiter</b> on <b>March 10, 2024, 01:21:50 PM</b>
					<hr />
					<div style="margin: 0 5ex;">A write up and examination of this code can be found here https://stacker.news/items/458544/r/BITC0IN</div>
					<br /><br />
					<div align="center" class="smalltext">
		<span class="smalltext" style="display: inline; visibility: visible; font-family: Verdana, Arial, sans-serif;"><a href="http://www.simplemachines.org/" title="Simple Machines Forum" target="_blank">Powered by SMF 1.1.19</a> | 
<a href="http://www.simplemachines.org/about/copyright.php" title="Free Forum Software" target="_blank">SMF &copy; 2006-2009, Simple Machines</a>
		</span></div>
				</td>
			</tr>
		</table>
	</body>
</html>